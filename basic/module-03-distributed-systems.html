<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Module 1.2b: Distributed Systems Fundamentals</title>
    <link rel="stylesheet" href="../shared/styles.css">
</head>
<body>
    <nav class="site-home-bar">
        <a href="../index.html" class="site-home-link" aria-label="Home">üè† Home</a>
    </nav>
    <div class="course-content">
        <div class="course-header">
            <h1>Module 1.2b: Distributed Systems Fundamentals</h1>
            <div class="course-meta">
                <span>‚è±Ô∏è Duration: 1.5-2 hours</span>
                <span>üìä Difficulty: Basic</span>
                <span>üìÖ Month 1, Week 2‚Äì3</span>
            </div>
        </div>

        <div class="section">
            <h2>Learning Objectives</h2>
            <ul>
                <li>Understand the <span data-glossary="cap theorem">CAP theorem</span> and its implications</li>
                <li>Learn about network partitions and how systems respond</li>
                <li>Understand eventual consistency vs strong consistency</li>
                <li>Learn about fault tolerance and failure modes</li>
            </ul>
        </div>

        <div class="section">
            <h2>1. The CAP Theorem</h2>
            
            <h3>What is CAP?</h3>
            <p>In a distributed system you cannot have all three at once:</p>
            <ul>
                <li><strong>C ‚Äì Consistency</strong>: Every read sees the latest write (all nodes agree on the same data at the same time).</li>
                <li><strong>A ‚Äì Availability</strong>: Every request receives a response (no request is refused).</li>
                <li><strong>P ‚Äì Partition tolerance</strong>: The system keeps working even when the network splits (messages are dropped or delayed between groups of nodes).</li>
            </ul>
            <p>In practice, <strong>partition tolerance (P) is non-negotiable</strong>‚Äînetworks do partition. So the real choice is:</p>
            <ul>
                <li><strong>CP</strong>: When a partition happens, sacrifice availability‚Äîrefuse some requests until the partition heals so that consistency is preserved.</li>
                <li><strong>AP</strong>: When a partition happens, sacrifice consistency‚Äîkeep answering requests so both sides can diverge; you get eventual consistency.</li>
            </ul>
            <div class="info">
                <strong>Blockchains and CAP:</strong> Many blockchains are CP-oriented: they prefer consistency (one agreed chain) and may not make progress during severe partitions. Some designs relax this for liveness (availability of new blocks) under partial synchrony.
            </div>
        </div>

        <div class="section">
            <h2>2. Network Partitions</h2>
            
            <h3>What is a Partition?</h3>
            <p>A <strong>network partition</strong> is when the network splits into two or more groups that cannot communicate with each other. Messages between groups are lost or delayed indefinitely.</p>
            <h3>Why It Matters</h3>
            <p>During a partition, nodes in different groups cannot agree in real time. So:</p>
            <ul>
                <li><strong>CP systems</strong> may stop accepting writes (or block progress) in one or both sides until the partition heals, to avoid inconsistent state.</li>
                <li><strong>AP systems</strong> allow both sides to keep accepting operations; when the partition heals, they must merge or resolve conflicts (eventual consistency).</li>
            </ul>
            <p>BFT consensus assumes that eventually the network is synchronous enough (e.g. after GST) so that a quorum can communicate. Until then, progress might stall (liveness), but safety (no two quorums commit different values) is preserved.</p>
        </div>

        <div class="section">
            <h2>3. Eventual Consistency vs Strong Consistency</h2>
            
            <h3>Strong Consistency</h3>
            <p>Every read sees the result of the latest completed write. All nodes agree on the same order and value. This is what <span data-glossary="consensus">consensus</span> and BFT aim for: one agreed sequence of blocks.</p>
            <h3>Eventual Consistency</h3>
            <p>If no new writes are made, eventually all nodes will converge to the same state. Before that, different nodes might see different data. Used in many AP systems (e.g. Dynamo-style, CRDTs).</p>
            <h3>In Blockchain</h3>
            <p>Blockchains typically want <strong>strong consistency</strong> on the canonical chain: once a block is committed (e.g. via BFT), all honest nodes agree. Nakamoto consensus gives <em>probabilistic</em> agreement (longest chain); BFT gives <em>deterministic</em> agreement.</p>
        </div>

        <div class="section">
            <h2>4. Fault Tolerance</h2>
            
            <h3>Failure Modes</h3>
            <ul>
                <li><strong>Crash</strong>: A node stops responding (no malicious behavior).</li>
                <li><strong>Byzantine</strong>: A node can behave arbitrarily (delay, drop, or send conflicting messages). BFT protocols tolerate up to f Byzantine nodes out of 3f+1.</li>
                <li><strong>Omission</strong>: Messages are dropped (can be modeled as crash or network partition).</li>
            </ul>
            <h3>Why It Matters for hyperscale-rs</h3>
            <p>Hyperscale-rs uses BFT consensus, so it is designed to tolerate Byzantine faults (up to 1/3 of validators). Understanding partitions and CAP helps you see why the protocol may not make progress during a partition (CP-style), and why quorum sizes (2f+1) are chosen so that any two quorums overlap in at least one honest node.</p>
        </div>

        <div class="section">
            <h2>5. Key Takeaways</h2>
            <ul>
                <li>CAP: under partitions, you trade off consistency (CP) vs availability (AP).</li>
                <li>Partitions mean groups of nodes cannot communicate; systems must choose how to behave.</li>
                <li>Strong consistency = everyone agrees on the same data; eventual consistency = everyone agrees eventually if writes stop.</li>
                <li>Fault tolerance (crash vs Byzantine) determines protocol design (e.g. 2f+1 vs 3f+1 nodes).</li>
            </ul>
        </div>

        <div class="section">
            <h2>6. Quiz</h2>
            <div id="quiz-03" class="quiz-container"></div>
        </div>

        <div class="section">
            <h2>7. Practical Assignment</h2>
            <div class="assignment">
                <h3>Assignment: CAP and Partitions</h3>
                <ol>
                    <li>In one paragraph, explain in your own words why a distributed system cannot guarantee consistency, availability, and partition tolerance at the same time.</li>
                    <li>Give one example of a system or product that favors CP, and one that favors AP. Briefly say why.</li>
                    <li>In your learning journal, note how BFT consensus (e.g. in hyperscale-rs) fits into the CAP picture (what is sacrificed during a partition?).</li>
                </ol>
                <h4>Success Criteria:</h4>
                <ul>
                    <li>‚úÖ You can explain CAP to someone else</li>
                    <li>‚úÖ You understand the difference between strong and eventual consistency</li>
                    <li>‚úÖ You can relate fault tolerance (crash vs Byzantine) to protocol choice</li>
                </ul>
            </div>
        </div>

        <div class="navigation">
            <a href="module-02-consensus-basics.html" class="btn btn-secondary">‚Üê Previous Module</a>
            <button id="complete-module-btn" class="btn btn-primary">Mark as Complete</button>
            <a href="module-04-state-machines.html" class="btn btn-primary">Next Module ‚Üí</a>
        </div>
    </div>

    <script src="../shared/course-data.js"></script>
    <script src="../shared/navigation.js"></script>
    <script src="../shared/glossary.js"></script>
    <script>
        initializeModulePage('basic-03');

        const quizQuestions = [
            {
                question: "In CAP, when a network partition occurs, what is the practical choice?",
                options: [
                    "Keep both C and A and give up P",
                    "Keep P and choose either CP or AP",
                    "Keep C and A and give up P",
                    "There is no choice"
                ],
                correct: 1
            },
            {
                question: "What does 'eventual consistency' mean?",
                options: [
                    "Data is always consistent immediately",
                    "If writes stop, all nodes eventually converge to the same state",
                    "Only one node can write at a time",
                    "Data is never consistent"
                ],
                correct: 1
            },
            {
                question: "In BFT with n = 3f+1 nodes, how many nodes can be Byzantine and the system still be safe?",
                options: [
                    "Up to 2f+1",
                    "Up to f",
                    "Up to 1",
                    "Zero"
                ],
                correct: 1
            },
            {
                question: "Why is partition tolerance (P) often considered non-negotiable?",
                options: [
                    "Because users demand it",
                    "Because networks can and do partition in practice",
                    "Because consistency is unimportant",
                    "Because availability is unimportant"
                ],
                correct: 1
            }
        ];

        initializeQuiz('quiz-03', quizQuestions, 70);
    </script>
</body>
</html>
