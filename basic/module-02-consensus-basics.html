<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Module 1.2: Consensus Algorithms - From Basics to BFT</title>
    <link rel="stylesheet" href="../shared/styles.css">
</head>
<body>
    <div class="course-content">
        <div class="course-header">
            <h1>Module 1.2: Consensus Algorithms - From Basics to BFT</h1>
            <div class="course-meta">
                <span>‚è±Ô∏è Duration: 1.5-2 hours</span>
                <span>üìä Difficulty: Basic</span>
                <span>üìÖ Month 1, Week 2</span>
            </div>
        </div>

        <div class="section">
            <h2>Learning Objectives</h2>
            <ul>
                <li>Understand the consensus problem in distributed systems</li>
                <li>Learn about Byzantine Fault Tolerance (BFT)</li>
                <li>Understand quorum certificates and voting</li>
                <li>Learn the basics of HotStuff-2 protocol</li>
                <li>Compare BFT with <span data-glossary="proof of stake">Proof-of-Stake (PoS)</span></li>
            </ul>
        </div>

        <div class="section">
            <h2>1. The Consensus Problem</h2>
            
            <h3>What is Consensus?</h3>
            <p>In a distributed system, <strong><span data-glossary="consensus">consensus</span></strong> is the process of getting all honest nodes to agree on a single value or sequence of values, even when some nodes may be faulty or malicious.</p>

            <div class="info">
                <strong>Example:</strong> Imagine 4 generals trying to coordinate an attack. One might be a traitor. How do the honest generals agree on a plan?
            </div>

            <h3>Why is Consensus Hard?</h3>
            <ul>
                <li><strong>Network delays</strong> - Messages arrive at different times</li>
                <li><strong>Node failures</strong> - Nodes can crash or go offline</li>
                <li><strong><span data-glossary="byzantine fault">Byzantine faults</span></strong> - Nodes can lie, send conflicting messages, or behave arbitrarily</li>
                <li><strong>Network partitions</strong> - Network can split into isolated groups</li>
            </ul>

            <h3>The <span data-glossary="flp impossibility">FLP Impossibility</span> Result</h3>
            <p>Fischer, Lynch, and Paterson proved that in an asynchronous network, it's <strong>impossible</strong> to guarantee consensus if even one node can fail. This is why blockchain systems make assumptions about network synchrony.</p>
        </div>

        <div class="section">
            <h2>2. Byzantine Fault Tolerance (BFT)</h2>
            
            <h3>What is BFT?</h3>
            <p><strong><span data-glossary="bft">Byzantine Fault Tolerance</span></strong> is the ability of a system to function correctly even when some nodes are Byzantine (malicious or faulty).</p>

            <h3>Fault Model</h3>
            <p>In a BFT system with <strong>n = 3f + 1</strong> nodes:</p>
            <ul>
                <li>Up to <strong>f</strong> nodes can be Byzantine (malicious)</li>
                <li>At least <strong>2f + 1</strong> nodes must be honest</li>
                <li>This ensures any two <span data-glossary="quorum">quorums</span> (groups of 2f+1) must overlap in at least one honest node</li>
            </ul>

            <div class="code-block"><pre><code>Example: n = 4, f = 1
- Total nodes: 4
- Byzantine nodes: up to 1
- Honest nodes: at least 3
- Quorum size: 2f + 1 = 3

Any two groups of 3 nodes must share at least 1 honest node.</code></pre></div>

            <h3>BFT vs <span data-glossary="crash fault">Crash Fault</span> Tolerance (CFT)</h3>
            <table style="width: 100%; border-collapse: collapse; margin: 1rem 0;">
                <tr style="background: var(--bg-secondary);">
                    <th style="padding: 0.5rem; border: 1px solid var(--border-color);">Aspect</th>
                    <th style="padding: 0.5rem; border: 1px solid var(--border-color);">CFT</th>
                    <th style="padding: 0.5rem; border: 1px solid var(--border-color);">BFT</th>
                </tr>
                <tr>
                    <td style="padding: 0.5rem; border: 1px solid var(--border-color);">Fault Model</td>
                    <td style="padding: 0.5rem; border: 1px solid var(--border-color);">Nodes crash</td>
                    <td style="padding: 0.5rem; border: 1px solid var(--border-color);">Nodes can be malicious</td>
                </tr>
                <tr>
                    <td style="padding: 0.5rem; border: 1px solid var(--border-color);">Tolerance</td>
                    <td style="padding: 0.5rem; border: 1px solid var(--border-color);">f out of 2f+1</td>
                    <td style="padding: 0.5rem; border: 1px solid var(--border-color);">f out of 3f+1</td>
                </tr>
                <tr>
                    <td style="padding: 0.5rem; border: 1px solid var(--border-color);">Use Case</td>
                    <td style="padding: 0.5rem; border: 1px solid var(--border-color);">Databases, distributed systems</td>
                    <td style="padding: 0.5rem; border: 1px solid var(--border-color);">Blockchains, critical systems</td>
                </tr>
            </table>
        </div>

        <div class="section">
            <h2>3. Quorum Certificates (QCs)</h2>
            
            <h3>What is a Quorum Certificate?</h3>
            <p>A <strong><span data-glossary="quorum certificate">Quorum Certificate (QC)</span></strong> is cryptographic proof that at least 2f+1 validators have voted for a block. It's an aggregated signature from a <span data-glossary="quorum">quorum</span> of validators.</p>

            <h3>Properties of QCs</h3>
            <ul>
                <li><strong>Cryptographic proof</strong> - Cannot be forged</li>
                <li><strong>Compact</strong> - Single aggregated signature (not 2f+1 individual signatures)</li>
                <li><strong>Verifiable</strong> - Anyone can verify the QC</li>
                <li><strong>Binding</strong> - Proves agreement on a specific block</li>
            </ul>

            <h3>How QCs Work - Detailed Mechanics</h3>
            
            <h4>Step-by-Step Process:</h4>
            <ol>
                <li><strong>Proposer broadcasts block header</strong>
                    <ul style="margin-top: 0.5rem;">
                        <li>The leader/proposer creates a new block at height H</li>
                        <li>This block includes the QC from the previous block (height H-1) in its header</li>
                        <li>The proposer broadcasts this block header to all validators</li>
                    </ul>
                </li>
                <li><strong>Validators validate and vote</strong>
                    <ul style="margin-top: 0.5rem;">
                        <li>Each validator receives the block header</li>
                        <li>Validators validate the block (check transactions, verify QC from previous block, etc.)</li>
                        <li>If valid, each validator creates a <strong>vote</strong> by cryptographically signing the block hash</li>
                        <li>Validators send their votes back to the proposer (or to a vote aggregator)</li>
                    </ul>
                </li>
                <li><strong>QC Generation - When and How</strong>
                    <div class="info" style="margin-top: 0.5rem; margin-left: 1rem;">
                        <strong>When QC gets generated:</strong> As soon as the proposer (or vote collector) receives 2f+1 valid votes for the block, a QC is immediately formed.
                    </div>
                    <ul style="margin-top: 0.5rem;">
                        <li>The proposer collects votes from validators</li>
                        <li>When 2f+1 votes are received, the proposer aggregates them into a single QC</li>
                        <li><strong>QC aggregation:</strong> Individual validator signatures are combined using signature aggregation (typically BLS signatures) into one compact aggregated signature</li>
                        <li>The QC contains: the block hash, the aggregated signature, and metadata (height, view number, etc.)</li>
                    </ul>
                </li>
                <li><strong>QC Inclusion in Next Block</strong>
                    <div class="highlight" style="margin-top: 0.5rem; margin-left: 1rem;">
                        <strong>How QC is included:</strong> The QC for block H is NOT broadcast separately. Instead, it's included directly in the header of block H+1 when the next proposer creates it.
                    </div>
                    <ul style="margin-top: 0.5rem;">
                        <li>The proposer who formed the QC includes it in their next block proposal (block H+1)</li>
                        <li>When the next leader proposes block H+1, they include the QC for block H in the block header</li>
                        <li>This QC serves as proof that block H was agreed upon by 2f+1 validators</li>
                        <li>All validators can verify the QC when they receive block H+1</li>
                    </ul>
                </li>
            </ol>

            <h4>Communication Flow:</h4>
            <div class="block-diagram">
                <div class="diagram-block">
                    <div class="block-header">
                        <div class="block-title">Block H Proposal</div>
                        <div class="block-field">- Proposer broadcasts block H</div>
                        <div class="block-field">- Includes QC for block H-1</div>
                    </div>
                </div>
                <div class="diagram-arrow">‚Üì</div>
                <div class="diagram-label">Validators receive & validate</div>
                <div class="diagram-arrow">‚Üì</div>
                <div class="diagram-block">
                    <div class="block-header">
                        <div class="block-title">Voting Phase</div>
                        <div class="block-field">- Validators send votes to proposer</div>
                        <div class="block-field">- Each vote = signed block hash</div>
                    </div>
                </div>
                <div class="diagram-arrow">‚Üì</div>
                <div class="diagram-label">When 2f+1 votes received</div>
                <div class="diagram-arrow">‚Üì</div>
                <div class="diagram-block">
                    <div class="block-header">
                        <div class="block-title">QC Formation</div>
                        <div class="block-field">- Proposer aggregates votes</div>
                        <div class="block-field">- Creates QC (aggregated signature)</div>
                    </div>
                </div>
                <div class="diagram-arrow">‚Üì</div>
                <div class="diagram-label">QC stored locally by proposer</div>
                <div class="diagram-arrow">‚Üì</div>
                <div class="diagram-block">
                    <div class="block-header">
                        <div class="block-title">Block H+1 Proposal</div>
                        <div class="block-field">- Next proposer includes QC for H</div>
                        <div class="block-field">- QC broadcast as part of block H+1</div>
                    </div>
                </div>
            </div>

            <div class="info" style="margin-top: 1.5rem;">
                <strong>Key Point:</strong> The QC is not broadcast immediately when formed. It's included in the next block's header, which is then broadcast. This means:
                <ul style="margin-top: 0.5rem;">
                    <li>Validators learn about the QC when they receive the next block</li>
                    <li>The QC proves the previous block was agreed upon</li>
                    <li>This creates a chain of QCs linking blocks together</li>
                </ul>
            </div>

            <h4>Example Timeline:</h4>
            <div class="code-block"><pre><code>Time T1: Proposer creates Block 10, includes QC for Block 9
Time T2: Proposer broadcasts Block 10 to all validators
Time T3: Validators validate Block 10 and send votes back
Time T4: Proposer receives 2f+1 votes ‚Üí QC for Block 10 is formed
         (QC stored locally, NOT broadcast yet)
Time T5: Next proposer creates Block 11, includes QC for Block 10
Time T6: Block 11 (with QC for Block 10) is broadcast
         ‚Üí All nodes now see that Block 10 has a QC</code></pre></div>
        </div>

        <div class="section">
            <h2>4. HotStuff-2 Protocol Basics</h2>
            
            <h3>What is HotStuff-2?</h3>
            <p><strong>HotStuff-2</strong> is a <span data-glossary="bft">BFT</span> consensus protocol that uses a <span data-glossary="two-chain commit">two-chain commit</span> rule. It's an improvement over traditional BFT protocols like <span data-glossary="pbft">PBFT</span>.</p>

            <h3>What is PBFT?</h3>
            <p><strong>PBFT (Practical Byzantine Fault Tolerance)</strong> is a classic BFT consensus protocol introduced by Castro and Liskov in 1999. It was one of the first practical BFT protocols that could handle Byzantine faults in asynchronous networks.</p>
            
            <h4>PBFT Characteristics:</h4>
            <ul>
                <li><strong>Three-phase commit</strong> - Requires three rounds of communication (pre-prepare, prepare, commit)</li>
                <li><strong>Three-chain commit rule</strong> - A block only commits after three consecutive blocks have QCs (quorum certificates)</li>
                <li><strong>Coordinated view changes</strong> - When the leader is suspected of being faulty, all nodes coordinate to vote on a new leader/view</li>
                <li><strong>Quadratic communication</strong> - O(n¬≤) messages per block (each node sends messages to all other nodes)</li>
                <li><strong>Explicit view-change protocol</strong> - Requires a separate voting phase to change views/leaders</li>
            </ul>

            <div class="info">
                <strong>Why PBFT matters:</strong> PBFT established the foundation for BFT consensus. Many modern protocols (including HotStuff-2) are improvements on PBFT's core ideas, addressing its limitations around communication complexity and view changes.
            </div>

            <h3>Key Features of HotStuff-2</h3>
            <ul>
                <li><strong><span data-glossary="two-chain commit">Two-chain commit</span></strong> - Block commits when next block gets <span data-glossary="qc">QC</span> (vs <span data-glossary="three-chain commit">3-chain</span> in <span data-glossary="pbft">PBFT</span>)
                    <div class="highlight" style="margin-top: 0.5rem; margin-left: 1rem;">
                        <strong>What this means:</strong> In <span data-glossary="pbft">PBFT</span>, you need blocks at heights H, H+1, and H+2 to all have <span data-glossary="qc">QCs</span> before H commits (<span data-glossary="three-chain commit">three-chain commit</span>). In HotStuff-2, you only need H and H+1 to have <span data-glossary="qc">QCs</span>. This reduces latency from 3 blocks to 2 blocks.
                    </div>
                </li>
                <li><strong><span data-glossary="implicit view change">Implicit view changes</span></strong> - No <span data-glossary="coordinated view-change">coordinated view-change voting</span>
                    <div class="highlight" style="margin-top: 0.5rem; margin-left: 1rem;">
                        <strong>What "<span data-glossary="coordinated view-change">coordinated view-change voting</span>" means:</strong> In <span data-glossary="pbft">PBFT</span>, when nodes suspect the leader is faulty, they must coordinate a <span data-glossary="view change">view-change</span>. This requires:
                        <ul style="margin-top: 0.5rem;">
                            <li>All nodes detecting the problem</li>
                            <li>A voting phase where nodes vote to change the view</li>
                            <li>Agreement on the new leader</li>
                            <li>State synchronization before resuming normal operation</li>
                        </ul>
                        This is complex and can cause delays. HotStuff-2 uses <strong><span data-glossary="implicit view change">implicit view changes</span></strong> - if a block doesn't get a <span data-glossary="qc">QC</span> within a timeout, nodes automatically advance to the next view/leader without explicit voting. The next leader simply proposes the next block, and if it gets a <span data-glossary="qc">QC</span>, the <span data-glossary="view change">view change</span> is implicitly accepted.
                    </div>
                </li>
                <li><strong>Optimistic pipelining</strong> - Multiple blocks can be in-flight</li>
                <li><strong>Linear communication</strong> - O(n) messages per block (vs O(n¬≤) in <span data-glossary="pbft">PBFT</span>)
                    <div class="highlight" style="margin-top: 0.5rem; margin-left: 1rem;">
                        <strong>Communication complexity:</strong> In PBFT, each node sends messages to all other nodes, resulting in n √ó n = n¬≤ messages. HotStuff-2 uses a leader-based approach where nodes only send messages to the leader, resulting in n messages per block.
                    </div>
                </li>
            </ul>

            <h3>Basic Flow</h3>
            <ol>
                <li><strong>Proposal</strong>: Proposer creates and broadcasts block header</li>
                <li><strong>Voting</strong>: Validators validate and vote</li>
                <li><strong>QC Formation</strong>: When 2f+1 votes collected, QC is formed</li>
                <li><strong>Commit</strong>: Block commits when next block gets QC (two-chain rule)</li>
            </ol>

            <h3>Two-Chain Commit Rule</h3>
            <p>Block at height H commits when block at height H+1 gets a QC.</p>
            <div class="code-block"><pre><code>Rule: Block H commits when block H+1 receives a QC.

Example scenario:
1. Block H is proposed and receives QC
2. Block H+1 is proposed and receives QC
   ‚Üí Block H NOW COMMITS (because H+1 has QC)
3. Block H+2 is proposed and receives QC
   ‚Üí Block H+1 NOW COMMITS (because H+2 has QC)

Visual representation:
Block H:    [has QC] ‚Üí commits when H+1 gets QC ‚úì
Block H+1:  [has QC] ‚Üí commits when H+2 gets QC (waiting...)
Block H+2:  [no QC yet] ‚Üí will commit when H+3 gets QC (waiting...)

The "two-chain" name comes from needing 2 consecutive blocks with QCs:
- H has QC and H+1 has QC ‚Üí H commits (2 blocks in chain)</code></pre></div>

            <div class="success">
                <strong>Why Two-Chain?</strong> Ensures <span data-glossary="finality">finality</span> even under network partitions. Only one chain can get consecutive QCs.
                
                <div style="margin-top: 1rem; padding-top: 1rem; border-top: 1px solid rgba(16, 185, 129, 0.3);">
                    <strong>Understanding Finality:</strong>
                    <p style="margin-top: 0.5rem;"><strong><span data-glossary="finality">Finality</span></strong> means once a block is committed, it cannot be reverted. In two-chain commit: Block H commits when H+1 gets a <span data-glossary="qc">QC</span>, creating a chain of QCs proving agreement by 2f+1 validators.</p>
                    <p style="margin-top: 0.5rem;">Under network partitions, only the majority partition (2f+1 validators) can produce consecutive QCs. The minority cannot, so their blocks won't commit. This ensures <strong>safety</strong>: only one valid chain exists, and committed blocks are permanent.</p>
                </div>
            </div>
        </div>

        <div class="section">
            <h2>5. BFT vs Proof-of-Stake (PoS)</h2>
            
            <h3>Key Differences</h3>
            <table style="width: 100%; border-collapse: collapse; margin: 1rem 0;">
                <tr style="background: var(--bg-secondary);">
                    <th style="padding: 0.5rem; border: 1px solid var(--border-color); text-align: center;">Aspect</th>
                    <th style="padding: 0.5rem; border: 1px solid var(--border-color); text-align: center;">BFT</th>
                    <th style="padding: 0.5rem; border: 1px solid var(--border-color); text-align: center;">PoS</th>
                </tr>
                <tr>
                    <td style="padding: 0.5rem; border: 1px solid var(--border-color);">Validator Set</td>
                    <td style="padding: 0.5rem; border: 1px solid var(--border-color); text-align: center;">Fixed, known</td>
                    <td style="padding: 0.5rem; border: 1px solid var(--border-color); text-align: center;">Dynamic, stake-weighted</td>
                </tr>
                <tr>
                    <td style="padding: 0.5rem; border: 1px solid var(--border-color);">Finality</td>
                    <td style="padding: 0.5rem; border: 1px solid var(--border-color); text-align: center;">Immediate, deterministic</td>
                    <td style="padding: 0.5rem; border: 1px solid var(--border-color); text-align: center;">Probabilistic, requires time</td>
                </tr>
                <tr>
                    <td style="padding: 0.5rem; border: 1px solid var(--border-color);">Communication</td>
                    <td style="padding: 0.5rem; border: 1px solid var(--border-color); text-align: center;">O(n) per block</td>
                    <td style="padding: 0.5rem; border: 1px solid var(--border-color); text-align: center;">O(1) per block</td>
                </tr>
                <tr>
                    <td style="padding: 0.5rem; border: 1px solid var(--border-color);">Fault Tolerance</td>
                    <td style="padding: 0.5rem; border: 1px solid var(--border-color); text-align: center;">f out of 3f+1</td>
                    <td style="padding: 0.5rem; border: 1px solid var(--border-color); text-align: center;">Up to 50% stake</td>
                </tr>
            </table>

            <h3>When to Use BFT</h3>
            <ul>
                <li>Need immediate finality</li>
                <li>Fixed validator set is acceptable</li>
                <li>High throughput is critical</li>
                <li>Deterministic safety guarantees needed</li>
            </ul>
        </div>

        <div class="section">
            <h2>6. Exploring BFT in Hyperscale-rs</h2>
            
            <h3>Key Files to Explore</h3>
            <ol>
                <li><code>crates/bft/src/lib.rs</code> - Read the module documentation</li>
                <li><code>crates/bft/src/state.rs</code> - BFT state machine implementation</li>
                <li><code>crates/bft/src/vote_set.rs</code> - Vote collection and QC formation</li>
                <li><code>guides/04-consensus-protocol.md</code> - Detailed protocol documentation</li>
            </ol>

            <h3>Practical Exercise</h3>
            <p>Open <code>crates/bft/src/lib.rs</code> and find:</p>
            <ul>
                <li>The definition of a quorum (how many votes needed?)</li>
                <li>The commit rule (when does a block commit?)</li>
                <li>The fault tolerance (how many Byzantine nodes can be tolerated?)</li>
            </ul>
        </div>

        <div class="section">
            <h2>7. Knowledge Check Quiz</h2>
            <div id="quiz-02" class="quiz-container"></div>
        </div>

        <div class="section">
            <h2>8. Practical Assignment</h2>
            <div class="assignment">
                <h3>Assignment: Understanding BFT Consensus</h3>
                
                <h4>Tasks:</h4>
                <ol>
                    <li><strong>Read Protocol Documentation</strong>:
                        <ul>
                            <li>Read <code>guides/04-consensus-protocol.md</code> completely</li>
                            <li>Read <code>crates/bft/src/lib.rs</code> documentation</li>
                            <li>Take notes on key concepts</li>
                        </ul>
                    </li>
                    <li><strong>Trace a Block Through Consensus</strong>:
                        <ul>
                            <li>Open <code>crates/bft/src/state.rs</code></li>
                            <li>Find the block proposal function</li>
                            <li>Find the vote handling function</li>
                            <li>Find the QC formation logic</li>
                            <li>Find the commit logic</li>
                            <li>Create a diagram showing the flow</li>
                        </ul>
                    </li>
                    <li><strong>Answer Questions</strong>:
                        <ul>
                            <li>In a system with 7 validators, how many can be Byzantine?</li>
                            <li>How many votes are needed for a quorum in a 7-validator system?</li>
                            <li>When does block H commit in HotStuff-2?</li>
                            <li>What is the difference between a vote and a QC?</li>
                        </ul>
                    </li>
                    <li><strong>Update Learning Journal</strong>:
                        <ul>
                            <li>Add a section on BFT consensus</li>
                            <li>Document what you learned</li>
                            <li>List questions you still have</li>
                        </ul>
                    </li>
                </ol>

                <h4>Success Criteria:</h4>
                <ul>
                    <li>‚úÖ You can explain BFT to someone else</li>
                    <li>‚úÖ You understand quorum certificates</li>
                    <li>‚úÖ You can trace through the code</li>
                    <li>‚úÖ You can answer the questions correctly</li>
                </ul>
            </div>
        </div>

        <div class="navigation">
            <a href="../../index.html" class="btn btn-secondary">‚Üê Back to Index</a>
            <button id="complete-module-btn" class="btn btn-primary">Mark as Complete</button>
            <a href="module-04-state-machines.html" class="btn btn-primary">Next Module ‚Üí</a>
        </div>
    </div>

    <script src="../shared/course-data.js"></script>
    <script src="../shared/navigation.js"></script>
    <script src="../shared/glossary.js"></script>
    <script>
        initializeModulePage('basic-02');

        const quizQuestions = [
            {
                question: "In a BFT system with n=7 validators, how many can be Byzantine?",
                options: [
                    "1",
                    "2",
                    "3",
                    "4"
                ],
                correct: 1
            },
            {
                question: "What is the minimum number of votes needed for a quorum in a 7-validator BFT system?",
                options: [
                    "3",
                    "4",
                    "5",
                    "6"
                ],
                correct: 2
            },
            {
                question: "When does a block commit in HotStuff-2?",
                options: [
                    "When it gets a QC",
                    "When the next block gets a QC (two-chain rule)",
                    "When 2f+1 validators vote",
                    "After a timeout period"
                ],
                correct: 1
            },
            {
                question: "What is a Quorum Certificate (QC)?",
                options: [
                    "A certificate from a single validator",
                    "Cryptographic proof that 2f+1 validators voted",
                    "A block that contains transactions",
                    "A network message"
                ],
                correct: 1
            },
            {
                question: "What is the main advantage of BFT over PoS?",
                options: [
                    "Lower communication overhead",
                    "Immediate, deterministic finality",
                    "Dynamic validator set",
                    "No need for cryptography"
                ],
                correct: 1
            }
        ];

        initializeQuiz('quiz-02', quizQuestions, 70);
    </script>
</body>
</html>