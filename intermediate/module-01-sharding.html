<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sharding & Cross-Shard Transactions</title>
    <link rel="stylesheet" href="../shared/styles.css">
</head>
<body>
    <nav class="site-home-bar">
        <a href="../index.html" class="site-home-link" aria-label="Home">üè† Home</a>
    </nav>
    <div class="course-content">
        <div class="course-header">
            <h1>Sharding & Cross-Shard Transactions</h1>
            <div class="course-meta">
                <span>‚è±Ô∏è Duration: 1.5‚Äì2 hours</span>
                <span>üìä Difficulty: Intermediate</span>
                <span>üìö General (any blockchain)</span>
            </div>
        </div>

        <div class="section">
            <h2>Learning Objectives</h2>
            <ul>
                <li>Understand <span data-glossary="sharding">sharding</span> concepts and why they matter for scalability</li>
                <li>Learn the <span data-glossary="two-phase commit">2PC</span> protocol for cross-shard atomicity</li>
                <li>Understand provision coordination (proofs across shards)</li>
                <li>Learn livelock prevention in cross-shard flow</li>
            </ul>
        </div>

        <div class="section">
            <h2>What is Sharding?</h2>
            <p><span data-glossary="sharding">Sharding</span> splits the system into multiple subsets (shards), each maintaining its own subset of state and running consensus among a subset of validators. Benefits include higher throughput (parallel execution) and smaller per-shard state. The challenge is <strong>cross-shard transactions</strong>: when a single logical transaction touches state on more than one shard, the system must coordinate so that the outcome is atomic (all shards commit or all abort).</p>
        </div>

        <div class="section">
            <h2>Two-Phase Commit (2PC)</h2>
            <p>In <span data-glossary="two-phase commit">2PC</span>, a coordinator drives two phases:</p>
            <ol>
                <li><strong>Prepare:</strong> The coordinator asks each participant (here, each involved shard) whether it can commit. Each shard runs its part of the transaction (e.g. <span data-glossary="prepare phase">lock or reserve</span> resources) but does <em>not</em> make the state change visible. It replies yes or no.</li>
                <li><strong>Commit or Abort:</strong> If <em>all</em> participants vote yes, the coordinator sends <strong>commit</strong> and each applies its state change. If any vote no (or timeout), the coordinator sends <strong>abort</strong> and everyone releases locks; no state change is applied.</li>
            </ol>
            <p>This gives atomicity: either every shard commits or none do. The order in which shards prepare and apply updates is fixed (e.g. by shard ID) so all nodes agree on the same outcome.</p>
        </div>

        <div class="section">
            <h2>Provision Coordination</h2>
            <p>Besides 2PC (prepare/commit/abort), cross-shard systems often need <strong>provisions</strong>: after a shard commits its block, it produces a signed proof (e.g. ‚Äústate at height H for this tx‚Äù) and sends it to other shards. A shard that depends on remote state cannot finish its view of the transaction until it has received enough of these proofs (e.g. quorum) from the other involved shards. So there are two coordination ideas:</p>
            <ul>
                <li><strong>2PC</strong> ‚Äì ‚ÄúCan everyone prepare? Commit or abort.‚Äù</li>
                <li><strong>Provisions</strong> ‚Äì ‚ÄúDo we have quorum of proofs from every other shard we need?‚Äù Only then can we consider the cross-shard tx complete on our shard.</li>
            </ul>
        </div>

        <div class="section">
            <h2>Livelock Prevention</h2>
            <p>In cross-shard protocols, livelock can occur if shards keep retrying or re-ordering without ever committing. Common techniques:</p>
            <ul>
                <li><strong>Deterministic order</strong> ‚Äì Use a fixed order (e.g. by shard ID) for prepare and for applying commits, so all nodes agree on the same sequence.</li>
                <li><strong>Timeouts and back-off</strong> ‚Äì If a participant doesn‚Äôt respond in time, abort and release resources so the system can make progress elsewhere.</li>
                <li><strong>Conflict detection</strong> ‚Äì Detect conflicting transactions and serialize or reject them so the system doesn‚Äôt spin forever.</li>
            </ul>
        </div>

        <div class="section">
            <h2>Next: Hyperscale-rs</h2>
            <p>In the next module you‚Äôll see how hyperscale-rs implements these ideas: 2PC in the execution crate, provision coordination in the provisions crate, and how protocol order (e.g. <code>ShardGroupId</code>) and livelock prevention are handled. Continue to <a href="../hyperscale-rs/module-05-cross-shard.html">Cross-Shard Transactions in Hyperscale-rs</a>.</p>
        </div>

        <div class="navigation">
            <a href="../hyperscale-rs/module-04-bft-implementation.html" class="btn btn-secondary">‚Üê Previous Module</a>
            <button id="complete-module-btn" class="btn btn-primary">Mark as Complete</button>
            <a href="../hyperscale-rs/module-05-cross-shard.html" class="btn btn-primary">Next Module ‚Üí</a>
        </div>
    </div>

    <script src="../shared/course-data.js"></script>
    <script src="../shared/navigation.js"></script>
    <script src="../shared/glossary.js"></script>
    <script>
        initializeModulePage('intermediate-02');
    </script>
</body>
</html>
