<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hyperscale-rs Overview & Setup</title>
    <link rel="stylesheet" href="../shared/styles.css">
</head>
<body>
    <nav class="site-home-bar">
        <a href="../index.html" class="site-home-link" aria-label="Home">üè† Home</a>
    </nav>
    <div class="course-content">
        <div class="course-header">
            <h1>Hyperscale-rs Overview & Setup</h1>
            <div class="course-meta">
                <span>‚è±Ô∏è Duration: 1.5-2 hours</span>
                <span>üìä Difficulty: Basic</span>
                <span>üéØ Hyperscale-rs Specific</span>
            </div>
        </div>

        <div class="section">
            <h2>Learning Objectives</h2>
            <p>By the end of this module, you will:</p>
            <ul>
                <li>Know what hyperscale-rs is and what it's not</li>
                <li>Understand the Hyperscale protocol and where to find it</li>
                <li>Understand the project's goals and design philosophy</li>
                <li>Have your development environment set up</li>
                <li>Know where to find key information in the codebase</li>
            </ul>
        </div>

        <div class="section">
            <h2>1. What is Hyperscale-rs?</h2>
            
            <h3>Hyperscale (the protocol)</h3>
            <p><strong>Hyperscale</strong> is the BFT <span data-glossary="consensus">consensus</span> protocol designed for high-throughput, <span data-glossary="sharding">sharded</span> blockchain networks. It defines how validators agree on blocks, handle <span data-glossary="cross-shard transaction">cross-shard</span> coordination, and achieve <span data-glossary="finality">finality</span>. The protocol design and specification are documented in the same repository as the Rust implementation.</p>
            <p><strong>Repository and docs:</strong> <a href="https://github.com/flightofthefox/hyperscale-rs" target="_blank" rel="noopener">github.com/flightofthefox/hyperscale-rs</a> ‚Äî code and protocol docs live here. The <strong>guides</strong> are markdown files in the repo‚Äôs <a href="https://github.com/flightofthefox/hyperscale-rs/tree/main/guides" target="_blank" rel="noopener"><code>guides/</code></a> directory (overview, architecture, codebase structure, consensus protocol).</p>
            
            <h3>Hyperscale-rs (the implementation)</h3>
            <p><strong><span data-glossary="hyperscale-rs">Hyperscale-rs</span></strong> is the Rust implementation of the Hyperscale protocol: a <span data-glossary="bft">Byzantine Fault Tolerant (BFT)</span> consensus system for high-throughput, sharded blockchain networks.</p>

            <div class="highlight">
                <strong>Key Point:</strong> Hyperscale-rs is NOT a full blockchain platform. It's a consensus layer ‚Äî the "engine" that decides which transactions get included and in what order.
            </div>

            <div class="info" style="margin-top: 1rem;">
                <strong>ü§î Think about it:</strong> If you were building a full wallet app, would the consensus layer (hyperscale-rs) be the only piece you need? What else would you need (e.g. execution, storage, networking to users)?
            </div>

            <h3>What Hyperscale-rs IS:</h3>
            <ul>
                <li>‚úÖ A BFT consensus protocol implementation</li>
                <li>‚úÖ Designed for high throughput and low latency</li>
                <li>‚úÖ Supports <span data-glossary="sharding">sharding</span> (dividing the network into parallel chains)</li>
                <li>‚úÖ Handles <span data-glossary="cross-shard transaction">cross-shard transactions</span> securely</li>
                <li>‚úÖ Pure consensus logic (no I/O, no locks, no async in core)</li>
                <li>‚úÖ <span data-glossary="deterministic">Deterministic</span> and testable</li>
            </ul>

            <h3>What Hyperscale-rs is NOT:</h3>
            <ul>
                <li>‚ùå A full blockchain platform (like Ethereum or Bitcoin)</li>
                <li>‚ùå A cryptocurrency (no native token)</li>
                <li>‚ùå A smart contract platform (though it integrates with Radix Engine)</li>
                <li>‚ùå A wallet or user-facing application</li>
                <li>‚ùå Production-ready (still work in progress)</li>
            </ul>

            <h3>Design Philosophy</h3>
            <p>Hyperscale-rs follows several key design principles:</p>
            <ol>
                <li><strong>Pure Consensus Layer</strong> ‚Äî No I/O, no locks, no async in consensus logic</li>
                <li><strong><span data-glossary="state machine">State Machine</span> Model</strong> ‚Äî Everything is a deterministic state machine</li>
                <li><strong><span data-glossary="event-driven">Event-Driven</span></strong> ‚Äî Events flow in, actions flow out</li>
                <li><strong><span data-glossary="deterministic">Deterministic</span> Testing</strong> ‚Äî Same code runs in simulation and production</li>
            </ol>

            <div class="info" style="margin-top: 1rem;">
                <strong>ü§î Check your understanding:</strong> Why do you think "no I/O in consensus logic" makes the code easier to test and reason about? (Hint: what would be hard if the consensus code could read the network or the clock whenever it wanted?)
            </div>

            <div class="warning" style="margin-top: 1.5rem;">
                <strong>Important Context:</strong> Hyperscale-rs is not a toy repo. It touches distributed systems, async Rust at scale, networking/performance, and architectural correctness. Contributions require different levels of expertise.
            </div>
        </div>

        <div class="section">
            <h2>2. Contribution Roadmap & Realistic Expectations</h2>
            
            <p>Understanding what contribution levels actually mean helps set realistic expectations. Here's a breakdown of what each level entails:</p>

            <table style="width: 100%; margin: 1.5rem 0;">
                <tr>
                    <th style="padding: 0.75rem; background: var(--bg2);">Level</th>
                    <th style="padding: 0.75rem; background: var(--bg2);">What It Actually Means</th>
                </tr>
                <tr>
                    <td style="padding: 0.75rem;"><strong>Basic</strong></td>
                    <td style="padding: 0.75rem;">Docs, tests, small refactors, safe bug fixes</td>
                </tr>
                <tr>
                    <td style="padding: 0.75rem;"><strong>Intermediate</strong></td>
                    <td style="padding: 0.75rem;">New components, performance fixes, API design</td>
                </tr>
                <tr>
                    <td style="padding: 0.75rem;"><strong>Advanced</strong></td>
                    <td style="padding: 0.75rem;">Architecture changes, consensus/network logic, scaling</td>
                </tr>
            </table>

            <div class="info">
                <strong>Time estimates</strong> assume 1‚Äì2 hours per day of focused study and practice. These are realistic ranges based on the complexity of each level.
            </div>

            <h3>1Ô∏è‚É£ Basic Contributions to Hyperscale-rs</h3>
            <p><strong>‚è±Ô∏è ~1‚Äì2 months</strong></p>
            
            <h4>What you'll be able to do:</h4>
            <ul>
                <li>‚úÖ Build & run the project locally</li>
                <li>‚úÖ Understand module boundaries</li>
                <li>‚úÖ Fix small bugs</li>
                <li>‚úÖ Improve documentation</li>
                <li>‚úÖ Add tests</li>
                <li>‚úÖ Make "safe" PRs that get merged</li>
            </ul>

            <h4>What you need to study:</h4>
            <ul>
                <li>Repo architecture</li>
                <li>Async Rust patterns (tokio, channels, lifetimes)</li>
                <li>Existing design docs / issues</li>
            </ul>

            <div class="success">
                <strong>This stage is faster for someone with Rust knowledge to complete:</strong>
            </div>

            <h3>2Ô∏è‚É£ Intermediate Contributions to Hyperscale-rs</h3>
            <p><strong>‚è±Ô∏è ~4‚Äì7 months total</strong> (including the first phase)</p>
            
            <h4>What "intermediate" really means:</h4>
            <ul>
                <li>Modify or extend subsystems</li>
                <li>Improve performance or correctness</li>
                <li>Design APIs used by others</li>
                <li>Reason about tradeoffs (latency vs throughput vs safety)</li>
            </ul>

            <h4>New mental models required:</h4>
            <ul>
                <li><strong>Distributed systems basics:</strong>
                    <ul>
                        <li>Failure modes</li>
                        <li>Partial failures</li>
                        <li>Backpressure</li>
                    </ul>
                </li>
                <li><strong>Blockchain internals:</strong>
                    <ul>
                        <li>State machines</li>
                        <li>Gossip / networking</li>
                        <li>Determinism</li>
                    </ul>
                </li>
                <li><strong>Rust performance profiling</strong></li>
            </ul>

            <div class="highlight">
                <strong>What changes here:</strong> You stop asking "What does this code do?" and start asking "What happens if this node is slow / malicious / partitioned?" That shift takes time. <strong>This is where many people stall. You probably won't.</strong>
            </div>

            <h3>3Ô∏è‚É£ Advanced Contributions to Hyperscale-rs</h3>
            <p><strong>‚è±Ô∏è ~12‚Äì24 months</strong></p>
            
            <div class="warning">
                <strong>This is the hard jump.</strong>
            </div>

            <h4>What "advanced" really means:</h4>
            <ul>
                <li>Designing or changing core architecture</li>
                <li>Modifying consensus or execution assumptions</li>
                <li>Introducing new scalability mechanisms</li>
                <li>Evaluating security tradeoffs</li>
                <li>Reviewing other people's protocol PRs</li>
            </ul>

            <h4>You must deeply understand:</h4>
            <ul>
                <li>Consensus algorithms (BFT, PoS variants)</li>
                <li>Network topology & message complexity</li>
                <li>State growth & pruning</li>
                <li>Cryptographic assumptions</li>
                <li>Economic incentives</li>
            </ul>

            <h4>Why this takes longer:</h4>
            <ul>
                <li>Knowledge compounds non-linearly</li>
                <li>Mistakes are expensive</li>
                <li>You're now operating in adversarial environments</li>
            </ul>

            <div class="info">
                <strong>Judgment matters more than speed.</strong>
            </div>
        </div>

        <div class="section">
            <h2>3. Project Structure</h2>
            
            <p>Hyperscale-rs is organized as a Cargo workspace with multiple crates:</p>

            <div class="code-block"><pre><code>hyperscale-rs/
‚îú‚îÄ‚îÄ crates/
‚îÇ   ‚îú‚îÄ‚îÄ core/          # Core types and traits
‚îÇ   ‚îú‚îÄ‚îÄ types/         # Shared types (blocks, votes, etc.)
‚îÇ   ‚îú‚îÄ‚îÄ bft/           # BFT consensus implementation
‚îÇ   ‚îú‚îÄ‚îÄ execution/     # Transaction execution
‚îÇ   ‚îú‚îÄ‚îÄ mempool/       # Transaction pool
‚îÇ   ‚îú‚îÄ‚îÄ node/          # Main node state machine
‚îÇ   ‚îú‚îÄ‚îÄ simulation/    # Deterministic simulator
‚îÇ   ‚îî‚îÄ‚îÄ production/    # Production runner
‚îú‚îÄ‚îÄ guides/            # Documentation (you are here!)
‚îî‚îÄ‚îÄ scripts/          # Helper scripts</code></pre></div>

            <h3>Key Files to Know</h3>
            <p>View these in the repo (links go to the file on GitHub):</p>
            <ul>
                <li><a href="https://github.com/flightofthefox/hyperscale-rs/blob/main/README.md" target="_blank" rel="noopener">README.md</a> ‚Äî project overview and setup</li>
                <li><a href="https://github.com/flightofthefox/hyperscale-rs/blob/main/guides/01-overview.md" target="_blank" rel="noopener">guides/01-overview.md</a> ‚Äî detailed project overview</li>
                <li><a href="https://github.com/flightofthefox/hyperscale-rs/blob/main/guides/02-architecture.md" target="_blank" rel="noopener">guides/02-architecture.md</a> ‚Äî architecture deep dive</li>
                <li><a href="https://github.com/flightofthefox/hyperscale-rs/blob/main/guides/03-codebase-structure.md" target="_blank" rel="noopener">guides/03-codebase-structure.md</a> ‚Äî codebase organization</li>
                <li><a href="https://github.com/flightofthefox/hyperscale-rs/blob/main/crates/core/src/traits.rs" target="_blank" rel="noopener">crates/core/src/traits.rs</a> ‚Äî <code>StateMachine</code> trait</li>
                <li><a href="https://github.com/flightofthefox/hyperscale-rs/blob/main/crates/node/src/state.rs" target="_blank" rel="noopener">crates/node/src/state.rs</a> ‚Äî main node implementation</li>
            </ul>
        </div>

        <div class="section">
            <h2>4. Setting Up Your Environment</h2>
            
            <h3>Prerequisites</h3>
            <ol>
                <li><strong>Install Rust</strong> (if not already installed):
                    <div class="code-block"><pre><code class="language-bash">curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh</code></pre></div>
                </li>
                <li><strong>Install Build Dependencies</strong>:
                    <ul>
                        <li>macOS: <code>brew install llvm protobuf openssl pkg-config</code></li>
                        <li>Linux: <code>sudo apt-get install clang lld pkg-config protobuf-compiler libssl-dev</code></li>
                    </ul>
                </li>
                <li><strong>Clone the Repository</strong>:
                    <div class="code-block"><pre><code class="language-bash">git clone --recurse-submodules https://github.com/flightofthefox/hyperscale-rs.git
cd hyperscale-rs</code></pre></div>
                </li>
                <li><strong>Build the Project</strong>:
                    <div class="code-block"><pre><code class="language-bash">cargo build --release</code></pre></div>
                </li>
                <li><strong>Run Tests</strong>:
                    <div class="code-block"><pre><code class="language-bash">cargo test</code></pre></div>
                </li>
            </ol>

            <div class="warning">
                <strong>Important:</strong> Make sure to clone with <code>--recurse-submodules</code> as the project uses git submodules for Radix Engine dependencies.
            </div>
        </div>

        <div class="section">
            <h2>5. Exploring the Codebase</h2>
            
            <h3>Practical Exercise</h3>
            <p>In the repo, do the following (each link opens the file on GitHub):</p>
            <ol>
                <li>Open the <a href="https://github.com/flightofthefox/hyperscale-rs/blob/main/README.md" target="_blank" rel="noopener">README</a> and read the "What's different" section</li>
                <li>Read <a href="https://github.com/flightofthefox/hyperscale-rs/blob/main/guides/01-overview.md" target="_blank" rel="noopener">guides/01-overview.md</a> ‚Äî focus on "What is Hyperscale?" and "Design Philosophy"</li>
                <li>Open <a href="https://github.com/flightofthefox/hyperscale-rs/blob/main/crates/core/src/traits.rs" target="_blank" rel="noopener">crates/core/src/traits.rs</a> and find the <code>StateMachine</code> trait</li>
                <li>Browse <a href="https://github.com/flightofthefox/hyperscale-rs/blob/main/crates/bft/src/lib.rs" target="_blank" rel="noopener">crates/bft/src/lib.rs</a> ‚Äî read the module documentation at the top</li>
                <li>Check <a href="https://github.com/flightofthefox/hyperscale-rs/blob/main/Cargo.toml" target="_blank" rel="noopener">Cargo.toml</a> ‚Äî see all workspace members</li>
            </ol>

            <h3>Questions to Answer</h3>
            <ul>
                <li>What makes hyperscale-rs different from other consensus implementations?</li>
                <li>Why is the "pure consensus layer" design important?</li>
                <li>What is the relationship between events and actions?</li>
            </ul>
        </div>

        <div class="section">
            <h2>6. Knowledge Check Quiz</h2>
            <div id="quiz-01" class="quiz-container"></div>
        </div>

        <div class="section">
            <h2>7. Practical Assignment</h2>
            <div class="assignment">
                <h3>Assignment: Environment Setup & First Exploration</h3>
                <p><strong>Goal:</strong> Set up your development environment and create a summary document.</p>
                
                <h4>Tasks:</h4>
                <ol>
                    <li><strong>Environment Setup</strong>:
                        <ul>
                            <li>Install all prerequisites</li>
                            <li>Clone the repository with submodules</li>
                            <li>Build the project successfully</li>
                            <li>Run the test suite</li>
                        </ul>
                    </li>
                    <li><strong>Codebase Exploration</strong>:
                        <ul>
                            <li>View the <a href="https://github.com/flightofthefox/hyperscale-rs/blob/main/README.md" target="_blank" rel="noopener">README</a> and <a href="https://github.com/flightofthefox/hyperscale-rs/blob/main/guides/01-overview.md" target="_blank" rel="noopener">guides/01-overview.md</a> in the repo</li>
                            <li>Explore at least 3 different crates (e.g. <a href="https://github.com/flightofthefox/hyperscale-rs/tree/main/crates/core" target="_blank" rel="noopener">core</a>, <a href="https://github.com/flightofthefox/hyperscale-rs/tree/main/crates/bft" target="_blank" rel="noopener">bft</a>, <a href="https://github.com/flightofthefox/hyperscale-rs/tree/main/crates/node" target="_blank" rel="noopener">node</a>)</li>
                            <li>Find and read the <a href="https://github.com/flightofthefox/hyperscale-rs/blob/main/crates/core/src/traits.rs" target="_blank" rel="noopener">StateMachine trait</a> definition</li>
                            <li>Identify one TODO or FIXME comment in the codebase (search in repo)</li>
                        </ul>
                    </li>
                    <li><strong>Create Summary Document</strong>:
                        <ul>
                            <li>Create a file: <code>MY_LEARNING_JOURNEY.md</code> in the root</li>
                            <li>Document what hyperscale-rs is and isn't (and how it relates to the Hyperscale protocol)</li>
                            <li>List 3 things you found interesting in the codebase</li>
                            <li>List 3 questions you have</li>
                        </ul>
                    </li>
                </ol>

                <h4>Success Criteria:</h4>
                <ul>
                    <li>‚úÖ Project builds without errors</li>
                    <li>‚úÖ All tests pass</li>
                    <li>‚úÖ Summary document created with meaningful content</li>
                    <li>‚úÖ You can explain what hyperscale-rs is to someone else</li>
                </ul>

                <h4>Next Steps:</h4>
                <p>Once complete, move to the next module. Don't worry if you don't understand everything yet - we'll dive deeper in subsequent modules!</p>
            </div>
        </div>

        <div class="navigation">
            <a href="../index.html" class="btn btn-secondary">‚Üê Back to Index</a>
            <button id="complete-module-btn" class="btn btn-primary">Mark as Complete</button>
            <a href="module-01b-tx-flow.html" class="btn btn-primary">Next Module ‚Üí</a>
        </div>
    </div>

    <script src="../shared/course-data.js"></script>
    <script src="../shared/navigation.js"></script>
    <script src="../shared/glossary.js"></script>
    <script>
        // Initialize module
        initializeModulePage('basic-05');

        // Conceptual quiz: tests understanding, not rote memorization
        const quizQuestions = [
            {
                question: "Why would a project keep consensus logic separate from I/O (network, disk, timers)?",
                options: [
                    "So that the same consensus code can be tested in simulation and run in production with the same behavior",
                    "To make the code run faster",
                    "To avoid using Rust",
                    "So that no one can run it on a real network"
                ],
                correct: 0,
                explanation: "If consensus could touch the network or clock directly, tests would depend on real time and real sockets ‚Äî flaky and hard to reproduce. By feeding in Events and executing Actions via a \"runner,\" the same state machine gets deterministic tests and real deployment."
            },
            {
                question: "Events flow *into* the state machine; Actions flow *out*. What problem does this separation solve?",
                options: [
                    "It makes the code shorter",
                    "The core logic only has to say \"what to do\" (actions); something else does the I/O and turns results into new events",
                    "It removes the need for any tests",
                    "It allows multiple programming languages"
                ],
                correct: 1,
                explanation: "The state machine stays pure: same state + same event ‚áí same actions. Runners (simulation or production) execute actions and inject new events. That way consensus is testable without mocking the whole world."
            },
            {
                question: "Someone says: \"Hyperscale-rs is like a mini Ethereum.\" What's the best response?",
                options: [
                    "Yes, it has smart contracts and a token",
                    "Not really ‚Äî it's just the consensus engine (agreement on blocks); execution and full chain behavior live elsewhere",
                    "It is exactly Ethereum but in Rust",
                    "It replaces Ethereum"
                ],
                correct: 1,
                explanation: "Hyperscale-rs implements agreement on a sequence of blocks (BFT, sharding). It doesn't implement execution, tokens, or smart contracts by itself; those are in other layers (e.g. Radix Engine) that build on top."
            },
            {
                question: "Why might \"deterministic\" matter for a consensus protocol?",
                options: [
                    "It makes the protocol faster than others",
                    "So that every honest node, given the same inputs and events, produces the same decisions and avoids forks from inconsistent behavior",
                    "Only for unit tests",
                    "It doesn't matter"
                ],
                correct: 1,
                explanation: "Consensus means everyone agrees. If the logic were non-deterministic (e.g. depended on random or wall clock), different nodes could reach different conclusions and the chain could fork. Determinism keeps everyone in sync."
            },
            {
                question: "What's one benefit of the Hyperscale protocol being designed for sharding from the start?",
                options: [
                    "Sharding is optional and rarely used",
                    "Throughput can scale with more shards; cross-shard coordination is part of the design",
                    "It uses less disk space",
                    "It avoids BFT entirely"
                ],
                correct: 1,
                explanation: "Sharding lets different groups of validators process different shards in parallel. Hyperscale is designed so that cross-shard transactions and coordination are first-class, instead of bolted on later."
            }
        ];

        initializeQuiz('quiz-01', quizQuestions, 70);
    </script>
</body>
</html>