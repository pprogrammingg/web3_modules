<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Transaction Flow: User to Finality</title>
    <link rel="stylesheet" href="../shared/styles.css" id="main-styles">
    <script>
    (function(){
        function ensureStyles() {
            var link = document.getElementById('main-styles');
            if (!link || (link.sheet && link.sheet.cssRules && link.sheet.cssRules.length > 0)) return;
            var p = location.pathname || '';
            var dir = p.replace(/\/[^/]*$/, '/');
            var up = dir.replace(/\/[^/]+\/$/, '/');
            if (up && up !== dir) {
                var fallback = document.createElement('link');
                fallback.rel = 'stylesheet';
                fallback.href = up + 'shared/styles.css';
                document.head.appendChild(fallback);
            }
        }
        if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', ensureStyles);
        else ensureStyles();
        setTimeout(ensureStyles, 150);
    })();
    </script>
</head>
<body>
    <nav class="site-home-bar">
        <a href="../index.html" class="site-home-link" aria-label="Home">üè† Home</a>
    </nav>
    <div class="course-content">
        <div class="course-header">
            <h1>Transaction Flow: User to Finality</h1>
            <div class="course-meta">
                <span>‚è±Ô∏è Duration: ~30 min</span>
                <span>üìä Difficulty: Basic</span>
                <span>üéØ Hyperscale-rs Specific</span>
            </div>
        </div>

        <div class="section">
            <h2>Why This Diagram?</h2>
            <p>Hyperscale-rs is a <strong>consensus layer</strong>, not a full blockchain stack. This diagram shows the end-to-end path of a transaction from the user to finality, and which parts Hyperscale touches versus which are outside (e.g. wallet, Radix Engine semantics, network client). Hover over each step to see which crates implement it.</p>
            <p><strong>Basic level:</strong> This is the only Hyperscale-specific basic module. The web3 modules (Blockchain, Consensus, Distributed Systems, State Machines) give foundation. After this, go to <strong>Intermediate</strong> for Hyperscale Overview, Crate Groups (with 10-question quizzes per group), Codebase Exploration, and First Contribution.</p>
            <p><strong>Where BFT comes in:</strong> Steps 1‚Äì6 get the tx into the system (user, network, node, cross-shard determination, <span data-glossary="mempool">mempool</span>, and for cross-shard txs, travel to involved <span data-glossary="sharding">shards</span>). <strong>BFT consensus runs from step 7</strong> (proposer selection) through step 11 (block committed) <em>per <span data-glossary="sharding">shard</span></em>. Steps 12‚Äì14 are execution, then (for cross-shard) coordination &amp; composition, then finality.</p>
        </div>

        <div class="section">
            <h2>End-to-End Transaction Flow</h2>
            <div class="tx-flow">
                <div class="tx-flow-legend">
                    <span><span class="dot-hyperscale"></span> Hyperscale-rs (consensus layer)</span>
                    <span><span class="dot-outside"></span> Outside Hyperscale (wallet, engine, network)</span>
                </div>
                <div class="tx-flow-diagram">
                    <!-- 1. User -->
                    <div class="flow-step outside">
                        <div class="flow-step-lane outside"></div>
                        <div class="flow-step-body">
                            <div class="flow-step-title">1. User signs transaction</div>
                            <div class="flow-step-desc">Wallet creates and signs a transaction (e.g. transfer, smart contract call).</div>
                            <div class="flow-step-popup">
                                <h4>Crates</h4>
                                <p class="outside-note">Not in Hyperscale ‚Äî wallet / client application.</p>
                            </div>
                        </div>
                    </div>
                    <div class="flow-step-arrow">‚Üì</div>

                    <!-- 2. Submit to network -->
                    <div class="flow-step outside">
                        <div class="flow-step-lane outside"></div>
                        <div class="flow-step-body">
                            <div class="flow-step-title">2. Transaction submitted to network</div>
                            <div class="flow-step-desc">RPC or gateway sends the signed tx to a node (or broadcast).</div>
                            <div class="flow-step-popup">
                                <h4>Crates</h4>
                                <p class="outside-note">Network client / RPC ‚Äî outside. <code>production</code> receives on the node side.</p>
                            </div>
                        </div>
                    </div>
                    <div class="flow-step-arrow">‚Üì</div>

                    <!-- 3. Node receives -->
                    <div class="flow-step hyperscale">
                        <div class="flow-step-lane hyperscale"></div>
                        <div class="flow-step-body">
                            <div class="flow-step-title">3. Node receives transaction</div>
                            <div class="flow-step-desc">Runner turns incoming bytes into <code>Event</code>s and feeds the node.</div>
                            <div class="flow-step-popup">
                                <h4>Crates</h4>
                                <ul>
                                    <li><a href="https://github.com/flightofthefox/hyperscale-rs/tree/main/crates/production" target="_blank" rel="noopener">production</a> ‚Äî I/O, turns network into events</li>
                                    <li><a href="https://github.com/flightofthefox/hyperscale-rs/tree/main/crates/node" target="_blank" rel="noopener">node</a> ‚Äî NodeStateMachine receives events</li>
                                </ul>
                            </div>
                        </div>
                    </div>
                    <div class="flow-step-arrow">‚Üì</div>

                    <!-- 4. Cross-shard determination -->
                    <div class="flow-step hyperscale">
                        <div class="flow-step-lane hyperscale"></div>
                        <div class="flow-step-body">
                            <div class="flow-step-title">4. Cross-shard determination</div>
                            <div class="flow-step-desc">The tx is analyzed for which <strong><span data-glossary="nodeid">NodeIDs</span></strong> (components, resources, packages, accounts) it reads or writes. If those NodeIDs belong to <strong>more than one <span data-glossary="sharding">shard</span></strong>, the tx is classified as a <strong><span data-glossary="cross-shard transaction">cross-shard transaction</span></strong>.</div>
                            <div class="flow-step-popup">
                                <h4>Crates</h4>
                                <ul>
                                    <li><a href="https://github.com/flightofthefox/hyperscale-rs/tree/main/crates/node" target="_blank" rel="noopener">node</a> ‚Äî routing, shard mapping</li>
                                    <li><a href="https://github.com/flightofthefox/hyperscale-rs/tree/main/crates/core" target="_blank" rel="noopener">core</a> ‚Äî Event/Action types</li>
                                </ul>
                                <p class="outside-note">Shard assignment of NodeIDs is defined by the protocol / Radix Engine; consensus uses it to decide single- vs cross-shard.</p>
                            </div>
                        </div>
                    </div>
                    <div class="flow-step-arrow">‚Üì</div>

                    <!-- 5. Mempool -->
                    <div class="flow-step hyperscale">
                        <div class="flow-step-lane hyperscale"></div>
                        <div class="flow-step-body">
                            <div class="flow-step-title">5. <span data-glossary="mempool">Mempool</span> (per <span data-glossary="sharding">shard</span>)</div>
                            <div class="flow-step-desc"><strong>Single-<span data-glossary="sharding">shard</span>:</strong> tx goes into that shard's <span data-glossary="mempool">mempool</span>. <strong>Cross-shard:</strong> the receiving node enqueues the tx in <strong>its own shard‚Äôs mempool</strong> (if the tx touches that shard). For other involved shards, the tx is sent in step 6 and nodes there enqueue it in their mempools ‚Äî so the tx ends up in the mempool of every involved shard.</div>
                            <div class="flow-step-popup">
                                <h4>Crates</h4>
                                <ul>
                                    <li><a href="https://github.com/flightofthefox/hyperscale-rs/tree/main/crates/mempool" target="_blank" rel="noopener">mempool</a> ‚Äî transaction pool</li>
                                    <li><a href="https://github.com/flightofthefox/hyperscale-rs/tree/main/crates/node" target="_blank" rel="noopener">node</a> ‚Äî composes mempool</li>
                                    <li><a href="https://github.com/flightofthefox/hyperscale-rs/tree/main/crates/core" target="_blank" rel="noopener">core</a> ‚Äî Event/Action types</li>
                                </ul>
                            </div>
                        </div>
                    </div>
                    <div class="flow-step-arrow">‚Üì</div>

                    <!-- 6. (Cross-shard) Tx travels to involved shards -->
                    <div id="step-6" class="flow-step hyperscale">
                        <div class="flow-step-lane hyperscale"></div>
                        <div class="flow-step-body">
                            <div class="flow-step-title">6. (Cross-shard) Tx travels to each involved shard</div>
                            <div class="flow-step-desc">For cross-shard txs, the receiving node (or the routing layer) <strong>sends</strong> the tx (or sub-transactions) to the nodes of every other involved <span data-glossary="sharding">shard</span>. Those nodes enqueue it in <strong>their</strong> shard‚Äôs mempool. A <strong>coordinator</strong> (one of these shards or a designated role) is chosen so that later (step 13) it can drive prepare/commit/abort in a fixed order. Each shard then runs steps 7‚Äì12 for its part.</div>
                            <div class="flow-step-popup">
                                <h4>Crates</h4>
                                <ul>
                                    <li><a href="https://github.com/flightofthefox/hyperscale-rs/tree/main/crates/provisions" target="_blank" rel="noopener">provisions</a> ‚Äî centralized provision coordination; drives cross-shard flow</li>
                                    <li><a href="https://github.com/flightofthefox/hyperscale-rs/tree/main/crates/production" target="_blank" rel="noopener">production</a> ‚Äî cross-shard messaging (libp2p Gossipsub on shard-scoped topics)</li>
                                    <li><a href="https://github.com/flightofthefox/hyperscale-rs/tree/main/crates/node" target="_blank" rel="noopener">node</a> ‚Äî composes provisions, coordination state</li>
                                </ul>
                                <p class="outside-note">In Hyperscale-rs, the node sends the tx to other shards via the production network layer: <strong>libp2p Gossipsub</strong> with shard-scoped topics (e.g. <code>hyperscale/{msg_type}/shard-{id}/1.0.0</code>). RPC is only for client‚Üínode submission.</p>
                                <p class="outside-note">livelock crate handles cross-shard deadlock detection and prevention.</p>
                            </div>
                        </div>
                    </div>
                    <div class="flow-step-arrow">‚Üì</div>

                    <!-- 7. Proposer selection -->
                    <div class="flow-step hyperscale">
                        <div class="flow-step-lane hyperscale"></div>
                        <div class="flow-step-body">
                            <div class="flow-step-title">7. Proposer selection (per <span data-glossary="sharding">shard</span>, per round)</div>
                            <div class="flow-step-desc">BFT starts here. Each <span data-glossary="sharding">shard</span> runs its own BFT instance with its own <span data-glossary="view">view/round</span>. The proposer (block leader) is chosen deterministically from the shard's validator set (e.g. round-robin by <strong>validator identity</strong> or <span data-glossary="view">view number</span> modulo validator count).</div>
                            <div class="flow-step-popup">
                                <h4>Crates</h4>
                                <ul>
                                    <li><a href="https://github.com/flightofthefox/hyperscale-rs/tree/main/crates/bft" target="_blank" rel="noopener">bft</a> ‚Äî view, leader election</li>
                                    <li><a href="https://github.com/flightofthefox/hyperscale-rs/tree/main/crates/core" target="_blank" rel="noopener">core</a> ‚Äî traits, time</li>
                                    <li><a href="https://github.com/flightofthefox/hyperscale-rs/tree/main/crates/types" target="_blank" rel="noopener">types</a> ‚Äî block, validator set</li>
                                </ul>
                            </div>
                        </div>
                    </div>
                    <div class="flow-step-arrow">‚Üì</div>

                    <!-- 8. Block proposal -->
                    <div class="flow-step hyperscale">
                        <div class="flow-step-lane hyperscale"></div>
                        <div class="flow-step-body">
                            <div class="flow-step-title">8. Block proposal</div>
                            <div class="flow-step-desc">Proposer builds block (header + txs from <span data-glossary="mempool">mempool</span>), broadcasts header; validators receive it.</div>
                            <div class="flow-step-popup">
                                <h4>Crates</h4>
                                <ul>
                                    <li><a href="https://github.com/flightofthefox/hyperscale-rs/tree/main/crates/bft" target="_blank" rel="noopener">bft</a> ‚Äî proposal logic</li>
                                    <li><a href="https://github.com/flightofthefox/hyperscale-rs/tree/main/crates/types" target="_blank" rel="noopener">types</a> ‚Äî Block, BlockHeader</li>
                                    <li><a href="https://github.com/flightofthefox/hyperscale-rs/tree/main/crates/node" target="_blank" rel="noopener">node</a> ‚Äî routes ProposalTimer, etc.</li>
                                </ul>
                            </div>
                        </div>
                    </div>
                    <div class="flow-step-arrow">‚Üì</div>

                    <!-- 9. Validators vote -->
                    <div class="flow-step hyperscale">
                        <div class="flow-step-lane hyperscale"></div>
                        <div class="flow-step-body">
                            <div class="flow-step-title">9. Validators vote</div>
                            <div class="flow-step-desc">Validators in this <span data-glossary="sharding">shard</span>'s BFT instance <strong>validate</strong> the block (e.g. check it extends from the parent QC, payload and hashes are valid, and it obeys consensus rules) and, if valid, sign a vote. 2f+1 votes are required for a quorum (BFT fault model: n = 3f+1 nodes per <span data-glossary="sharding">shard</span>).</div>
                            <div class="flow-step-popup">
                                <h4>Crates</h4>
                                <ul>
                                    <li><a href="https://github.com/flightofthefox/hyperscale-rs/tree/main/crates/bft" target="_blank" rel="noopener">bft</a> ‚Äî block validation logic and voting; collects votes</li>
                                    <li><a href="https://github.com/flightofthefox/hyperscale-rs/tree/main/crates/types" target="_blank" rel="noopener">types</a> ‚Äî Block, Vote, signatures</li>
                                </ul>
                            </div>
                        </div>
                    </div>
                    <div class="flow-step-arrow">‚Üì</div>

                    <!-- 10. QC formed -->
                    <div class="flow-step hyperscale">
                        <div class="flow-step-lane hyperscale"></div>
                        <div class="flow-step-body">
                            <div class="flow-step-title">10. Quorum certificate (QC) formed</div>
                            <div class="flow-step-desc">How a QC is formed: <strong>(i)</strong> Proposer for H built and broadcast the block header (step 8). <strong>(ii)</strong> Validators validated and voted; votes are broadcast to the shard (step 9). <strong>(iii)</strong> When any validator has 2f+1 valid votes, it requests QC build; that node‚Äôs <code>latest_qc</code> is set to the new QC. <strong>(iv)</strong> The QC is not sent as a separate message‚Äîthe next proposer has it by forming it from votes or from a received block header. <strong>(v)</strong> The next proposer builds block H+1 with <code>parent_qc</code> = QC(H) and broadcasts H+1; everyone then sees QC(H) in H+1‚Äôs header.</div>
                            <div class="flow-step-popup">
                                <h4>Crates &amp; code</h4>
                                <ul>
                                    <li><a href="https://github.com/flightofthefox/hyperscale-rs/tree/main/crates/bft" target="_blank" rel="noopener">bft</a> ‚Äî vote collection, QC build request, <code>latest_qc</code>, block build with <code>parent_qc</code></li>
                                    <li><a href="https://github.com/flightofthefox/hyperscale-rs/tree/main/crates/types" target="_blank" rel="noopener">types</a> ‚Äî <code>BlockHeader.parent_qc</code> (block.rs:75), <code>QuorumCertificate</code></li>
                                    <li><a href="https://github.com/flightofthefox/hyperscale-rs/tree/main/crates/core" target="_blank" rel="noopener">core</a> ‚Äî <code>Action::PersistAndBroadcastVote</code> (action.rs:444), <code>Action::VerifyAndBuildQuorumCertificate</code> (action.rs:113)</li>
                                </ul>
                                <p style="margin: 0.5rem 0 0 0; font-size: 0.85rem;"><strong>Locations:</strong> BFT state emits vote broadcast in <code>bft/src/state.rs</code> (‚âà2575), emits QC build in <code>bft/src/state.rs</code> (‚âà2765); <code>on_qc_formed</code> sets <code>latest_qc</code> (state.rs:3583); <code>latest_qc</code> from received header (state.rs:1597); block build uses <code>latest_qc</code> as <code>parent_qc</code> (state.rs:1013‚Äì1017, 1147, 1182‚Äì1208). <code>vote_set.build_qc</code> in <code>bft/src/vote_set.rs</code> (307).</p>
                            </div>
                        </div>
                    </div>
                    <div class="flow-step-arrow">‚Üì</div>

                    <!-- 11. Block committed -->
                    <div class="flow-step hyperscale">
                        <div class="flow-step-lane hyperscale"></div>
                        <div class="flow-step-body">
                            <div class="flow-step-title">11. Block committed</div>
                            <div class="flow-step-desc"><strong>Who:</strong> Every validator <strong>node</strong> in the shard (not only the proposer). Once the commit rule is satisfied (e.g. two-chain: this block and the next have QCs), each node commits. <strong>Commit mechanics:</strong> (1) accept the block as final, (2) append it to the local chain, (3) trigger execution (run the transactions in the block), (4) trigger persistence (write to storage). All honest nodes do this in sync with the agreed order.</div>
                            <div class="flow-step-popup">
                                <h4>Crates</h4>
                                <ul>
                                    <li><a href="https://github.com/flightofthefox/hyperscale-rs/tree/main/crates/node" target="_blank" rel="noopener">node</a> ‚Äî CommitBlock action, composition</li>
                                    <li><a href="https://github.com/flightofthefox/hyperscale-rs/tree/main/crates/bft" target="_blank" rel="noopener">bft</a> ‚Äî commit rule</li>
                                    <li><a href="https://github.com/flightofthefox/hyperscale-rs/tree/main/crates/core" target="_blank" rel="noopener">core</a> ‚Äî Action::CommitBlock</li>
                                </ul>
                                <p class="outside-note">‚ÄúNode‚Äù = any validator running the NodeStateMachine in this shard; the proposer is one of them. All commit the same block in the same order.</p>
                            </div>
                        </div>
                    </div>
                    <div class="flow-step-arrow">‚Üì</div>

                    <!-- 12. Execution -->
                    <div class="flow-step hyperscale">
                        <div class="flow-step-lane hyperscale"></div>
                        <div class="flow-step-body">
                            <div class="flow-step-title">12. Execution</div>
                            <div class="flow-step-desc">Transactions in the block are executed (per <span data-glossary="sharding">shard</span>). Hyperscale runs the execution state machine; semantics (e.g. Radix Engine) may be external.</div>
                            <div class="flow-step-popup">
                                <h4>Crates</h4>
                                <ul>
                                    <li><a href="https://github.com/flightofthefox/hyperscale-rs/tree/main/crates/execution" target="_blank" rel="noopener">execution</a> ‚Äî execution state machine; cross-shard 2PC coordination</li>
                                    <li><a href="https://github.com/flightofthefox/hyperscale-rs/tree/main/crates/engine" target="_blank" rel="noopener">engine</a> ‚Äî Radix Engine integration for smart contract execution</li>
                                    <li><a href="https://github.com/flightofthefox/hyperscale-rs/tree/main/crates/node" target="_blank" rel="noopener">node</a> ‚Äî composes execution</li>
                                </ul>
                                <p class="outside-note">Execution semantics (Radix Engine) are in engine crate / vendor; BFT only orders and coordinates.</p>
                            </div>
                        </div>
                    </div>
                    <div class="flow-step-arrow">‚Üì</div>

                    <!-- 13. (Cross-shard) Coordination & composition -->
                    <div id="step-13" class="flow-step hyperscale">
                        <div class="flow-step-lane hyperscale"></div>
                        <div class="flow-step-body">
                            <div class="flow-step-title">13. (Cross-shard) Coordination &amp; composition</div>
                            <div class="flow-step-desc">For <strong>cross-shard</strong> txs, <strong>atomic composability</strong> works like this. <strong>Communication &amp; order:</strong> Shards talk in a fixed protocol order (e.g. one <strong>coordinator <span data-glossary="sharding">shard</span></strong> drives <span data-glossary="two-phase commit">2PC</span>). It sends <strong>prepare</strong> to each involved shard; each shard runs its part (<span data-glossary="prepare phase">lock/reserve</span>, no visible state change yet) and replies yes/no. If <strong>all</strong> vote yes, coordinator sends <strong>commit</strong>; otherwise <strong>abort</strong>. <strong>State updates:</strong> Only after the decision, each shard applies updates in an <strong>agreed order</strong> (e.g. by shard ID or coordinator order) ‚Äî commit = apply state; abort = release locks. That way every node sees the same composed outcome and no shard commits while another aborts. Single-shard txs skip this.</div>
                            <div class="flow-step-popup">
                                <h4>Crates</h4>
                                <ul>
                                    <li><a href="https://github.com/flightofthefox/hyperscale-rs/tree/main/crates/provisions" target="_blank" rel="noopener">provisions</a> ‚Äî centralized provision coordination for cross-shard txs</li>
                                    <li><a href="https://github.com/flightofthefox/hyperscale-rs/tree/main/crates/execution" target="_blank" rel="noopener">execution</a> ‚Äî transaction execution with cross-shard <span data-glossary="two-phase commit">2PC</span> coordination</li>
                                    <li><a href="https://github.com/flightofthefox/hyperscale-rs/tree/main/crates/node" target="_blank" rel="noopener">node</a> ‚Äî composes provisions, execution, core</li>
                                    <li><a href="https://github.com/flightofthefox/hyperscale-rs/tree/main/crates/core" target="_blank" rel="noopener">core</a> ‚Äî Event/Action for coordination</li>
                                </ul>
                                <p class="outside-note">See module ‚ÄúCross-Shard Transactions‚Äù for 2PC and provision coordination details.</p>
                            </div>
                        </div>
                    </div>
                    <div class="flow-step-arrow">‚Üì</div>

                    <!-- 14. Finality -->
                    <div class="flow-step hyperscale">
                        <div class="flow-step-lane hyperscale"></div>
                        <div class="flow-step-body">
                            <div class="flow-step-title">14. Finality &amp; persistence</div>
                            <div class="flow-step-desc">BFT gives one-round finality (no reorg after QC). State/storage may be in-node or external.</div>
                            <div class="flow-step-popup">
                                <h4>Crates</h4>
                                <ul>
                                    <li><a href="https://github.com/flightofthefox/hyperscale-rs/tree/main/crates/bft" target="_blank" rel="noopener">bft</a> ‚Äî finality rule</li>
                                    <li><a href="https://github.com/flightofthefox/hyperscale-rs/tree/main/crates/node" target="_blank" rel="noopener">node</a> ‚Äî state, persistence</li>
                                </ul>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            <p style="margin-top: 1rem; font-size: 0.9rem; color: var(--text2);"><strong>Tip:</strong> Hover over a step to see which crates implement it. Popup closes when you move the cursor away.</p>

            <div class="section section-tight">
                <h3>Clarifying the flow (multi-shard and proposer)</h3>
                <p>A few common points to keep straight:</p>
                <ul>
                    <li><strong>Proposer is per shard, per round.</strong> The node that receives the tx (e.g. via RPC) belongs to some shard, but that does <em>not</em> make it the proposer. Proposer is chosen <strong>deterministically per shard</strong> (e.g. round-robin by view). So for shard A, ‚Äúthe proposer for this round‚Äù is one validator in A; for shard B, it‚Äôs one validator in B. They are different nodes. The receiving node just ingests the tx (steps 3‚Äì6); the tx lands in <strong>mempool(s)</strong> of every involved shard. The proposer <strong>pulls</strong> from its shard‚Äôs mempool when its <strong>ProposalTimer</strong> fires and builds a block ‚Äî it doesn‚Äôt ‚Äúreceive the tx‚Äù specially.</li>
                    <li><strong>Who enqueues in which mempool?</strong> The node that receives the tx (e.g. RPC node) belongs to one shard. It can enqueue the tx in <strong>its own shard‚Äôs mempool</strong> (if the tx touches that shard). It cannot directly enqueue into another shard‚Äôs mempool ‚Äî that shard‚Äôs mempool lives on that shard‚Äôs nodes. So for cross-shard: the receiving node enqueues in its shard‚Äôs mempool (step 5) and <strong>sends</strong> the tx (or sub-tx) to the other involved shards (step 6). Nodes in those shards receive it and enqueue it in <strong>their</strong> mempools. So the tx ends up in the mempools of every involved shard, but ‚Äúenqueue in mempools of every involved shard‚Äù is done by the receiving node for its shard and by the other shards‚Äô nodes when they receive the tx.</li>
                    <li><strong>Tx does not ‚Äúbroadcast until it lands on the proposer.‚Äù</strong> Once the tx is in the mempools (as above), each shard‚Äôs proposer pulls from <em>that shard‚Äôs</em> mempool when its ProposalTimer fires and builds a block. The proposer broadcasts the <strong>block (header)</strong> to <strong>validators in that shard only</strong>, not to other shards.</li>
                    <li><strong>Proposer sends a block to its shard, not ‚Äúthe block‚Äù to all shards.</strong> The proposer for <strong>shard S</strong> builds <strong>one block</strong> (header with <code>parent_qc</code> = QC for previous block in S‚Äôs chain, plus txs from S‚Äôs mempool). It broadcasts that block (or header; full block is assembled via gossip) to <strong>validators in shard S only</strong>. So: one block per shard, broadcast inside that shard. Other shards have their own proposers and their own blocks at the same ‚Äúlogical‚Äù time.</li>
                    <li><strong>Voting and execution order.</strong> Validators in <strong>that shard</strong> vote on the <strong>block</strong> (BFT: do we agree on this block?). That yields a QC for that shard‚Äôs block. Then the block is committed (step 11). <strong>After</strong> commit, execution runs (step 12): the transactions in the block are run (e.g. via Radix Engine). So: BFT agrees on block ‚Üí commit ‚Üí then execute. There is no ‚Äúeach shard votes on validity and reports to the proposer‚Äù in the sense of one global proposer; each shard votes on its own block and gets its own QC.</li>
                    <li><strong>Cross-shard: no single ‚Äúproposer finalizes with all shards‚Äô QCs.‚Äù</strong> Each shard has its <strong>own</strong> chain and its <strong>own</strong> QC. For a cross-shard tx, the tx (or sub-tx) is in each involved shard‚Äôs mempool; each shard may include it in its block; each shard runs BFT (propose ‚Üí vote ‚Üí QC ‚Üí commit) and then execution. <strong>Atomicity across shards</strong> is achieved by <strong>2PC</strong> (step 13): a coordinator drives prepare ‚Üí all shards prepare (lock/reserve) and reply yes/no ‚Üí commit or abort ‚Üí each shard applies state in an agreed order. So ‚Äúall report success‚Äù is the 2PC prepare phase; then commit/abort and apply. There is no single block that ‚Äúincludes the votes (QC) of each shard‚Äù ‚Äî each shard‚Äôs block has its own QC in the <em>next</em> block‚Äôs header (the normal two-chain rule per shard).</li>
                    <li><strong>What is the coordinator?</strong> For the full picture (2PC coordinator vs ProvisionCoordinator, protocol order, concepts), see the <strong>Intermediate</strong> module <a href="module-05-cross-shard.html">Cross-Shard Transactions in Hyperscale-rs</a>.</li>
                </ul>
            </div>

            <p class="info section-tight" style="margin-top: 1rem;">For <strong>how atomic composability works</strong> (prepare ‚Üí commit/abort ‚Üí state updates), the <strong>two coordinators</strong> (2PC vs ProvisionCoordinator), <strong>how order is fixed</strong>, manifest vs protocol order, and <strong>concepts</strong> (shards, proposer, NodeID, finality), see the Intermediate module <a href="module-05-cross-shard.html">Cross-Shard Transactions in Hyperscale-rs</a>.</p>

        <div class="section">
            <h2>Crate groupings (code reading order)</h2>
            <p>The codebase is grouped by <strong>transaction-flow progression</strong>. Read the groups in order (1 ‚Üí 6); use the quizzes in the next module to check understanding.</p>
            <div class="code-block-light" style="overflow-x: auto;">
                <table style="width: 100%; min-width: 640px; border-collapse: collapse;">
                    <thead>
                        <tr style="background: var(--bg2);">
                            <th style="padding: 0.5rem; text-align: left; border: 1px solid var(--border);">Group</th>
                            <th style="padding: 0.5rem; text-align: left; border: 1px solid var(--border);">Crates</th>
                            <th style="padding: 0.5rem; text-align: left; border: 1px solid var(--border);">One-liner</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr><td style="padding: 0.5rem; border: 1px solid var(--border);"><strong>1. First contact</strong></td><td style="padding: 0.5rem; border: 1px solid var(--border);">production, node, mempool, types, core, messages</td><td style="padding: 0.5rem; border: 1px solid var(--border);">How Hyperscale receives a tx at the RPC and gets it into the right shards‚Äô mempools.</td></tr>
                        <tr><td style="padding: 0.5rem; border: 1px solid var(--border);"><strong>2. Sharding and routing</strong></td><td style="padding: 0.5rem; border: 1px solid var(--border);">types, core, node</td><td style="padding: 0.5rem; border: 1px solid var(--border);">Who does what once a tx is decomposed into NodeIds and each shard is responsible for a slice of state.</td></tr>
                        <tr><td style="padding: 0.5rem; border: 1px solid var(--border);"><strong>3. Proposing and building blocks</strong></td><td style="padding: 0.5rem; border: 1px solid var(--border);">bft, mempool, types, core</td><td style="padding: 0.5rem; border: 1px solid var(--border);">How one validator becomes the proposer and assembles the next block from the mempool.</td></tr>
                        <tr><td style="padding: 0.5rem; border: 1px solid var(--border);"><strong>4. Voting and committing</strong></td><td style="padding: 0.5rem; border: 1px solid var(--border);">bft, types, core</td><td style="padding: 0.5rem; border: 1px solid var(--border);">How validators agree on a block and when it is finally committed (votes and QCs).</td></tr>
                        <tr><td style="padding: 0.5rem; border: 1px solid var(--border);"><strong>5. Execution after commit</strong></td><td style="padding: 0.5rem; border: 1px solid var(--border);">execution, engine, node, types, core</td><td style="padding: 0.5rem; border: 1px solid var(--border);">Who runs transactions after commit and how single-shard vs cross-shard paths diverge.</td></tr>
                        <tr><td style="padding: 0.5rem; border: 1px solid var(--border);"><strong>6. Cross-shard: provisions and livelock</strong></td><td style="padding: 0.5rem; border: 1px solid var(--border);">provisions, execution, livelock, types, core</td><td style="padding: 0.5rem; border: 1px solid var(--border);">How state moves between shards and how Hyperscale avoids deadlock.</td></tr>
                    </tbody>
                </table>
            </div>
            <p style="margin-top: 1rem;">In <strong>Intermediate</strong>, do <a href="module-01c-crate-groups.html">Crate Groups &amp; Quizzes</a> next (one-liners, code pointers, 10-question quiz per group).</p>
        </div>

        <div class="section">
            <h2>Practical next steps: run the code and debug</h2>
            <p>Use these steps to run Hyperscale and follow a transaction with a debugger. They assume you have the repo cloned and <code>cargo build</code> works.</p>
            <ol>
                <li><strong>Read <code>Event</code> and <code>Action</code> first.</strong> The flow is ‚Äúevent in ‚Üí state machine ‚Üí actions out; runner performs actions and feeds back events.‚Äù Skim <code>core::event</code> and <code>core::action</code> (e.g. <code>action.rs</code> / <code>event.rs</code>) so you know what to break on.</li>
                <li><strong>Run a node or the simulator.</strong> Follow the repo README to run a single node or the sim (e.g. <code>cargo run</code> for the production runner or sim binary). Submit one transaction and note its hash (from logs or RPC).</li>
                <li><strong>Follow one tx with a debugger.</strong> In your IDE, set breakpoints on: <code>SubmitTransaction</code> / <code>TransactionGossipReceived</code> (first contact), then <code>BlockCommitted</code> (BFT), then <code>TransactionExecuted</code> (execution), then where the certificate is included in a block and status becomes <code>Completed</code>. Step through to see which crates handle each step.</li>
                <li><strong>Use the crate table.</strong> The production runner is large. Use the table above to jump to ‚Äúfirst contact‚Äù (RPC handler, submit path, gossip) and ‚Äúactions to network‚Äù (e.g. <code>BroadcastToShard</code> handling) instead of reading the production crate top to bottom.</li>
                <li><strong>When things go wrong:</strong> tx stuck in <strong>Pending</strong> ‚Üí check mempool and gossip (did the tx reach all involved shards?). Block not <strong>committing</strong> ‚Üí BFT and QC (round/timeout, vote collection). Cross-shard tx stuck after <strong>Executed</strong> ‚Üí certificates and inclusion in a later block (provisions, certificate aggregation).</li>
            </ol>
        </div>

        <div class="section">
            <h2>Quiz: Transaction Flow (big picture)</h2>
            <p>Answer based on the diagram and concepts above. Pass threshold: 70%.</p>
            <div id="quiz-tx-flow" class="quiz-container"></div>
        </div>

        <div class="navigation">
            <a href="../basic/module-04-state-machines.html" class="btn btn-secondary">‚Üê Previous Module</a>
            <button id="complete-module-btn" class="btn btn-primary">Mark as Complete</button>
            <a href="module-03-first-contribution.html" class="btn btn-primary">Next Module ‚Üí</a>
        </div>
    </div>

    <script src="../shared/course-data.js"></script>
    <script src="../shared/navigation.js"></script>
    <script src="../shared/glossary.js"></script>
    <script>
        initializeModulePage('basic-05b');
        const quizQuestions = [
            {
                question: "At which step does BFT consensus first participate in the transaction flow?",
                options: [
                    "Step 7 (Proposer selection)",
                    "Step 4 (Cross-shard determination)",
                    "Step 5 (Mempool)",
                    "Step 3 (Node receives)"
                ],
                correct: 0,
                explanation: "BFT runs from step 7 (proposer selection) through step 11 (block committed) per shard. Steps 1‚Äì6 are about getting the tx into the system (user, network, node, cross-shard determination, mempool, travel to shards)."
            },
            {
                question: "How is a transaction classified as cross-shard?",
                options: [
                    "If it is submitted from a wallet that has accounts on multiple shards",
                    "If the NodeIDs (components, resources, packages, accounts) it reads or writes belong to more than one shard",
                    "If it is larger than a size threshold defined by the coordinator",
                    "If it is the first transaction in a new block"
                ],
                correct: 1,
                explanation: "Cross-shard determination (step 4) analyzes which NodeIDs the tx reads or writes. If those NodeIDs belong to more than one shard, the tx is cross-shard."
            },
            {
                question: "Who defines which shard a NodeID (e.g. a component address) belongs to?",
                options: [
                    "Each validator decides locally to balance load",
                    "The protocol / Radix Engine; consensus uses that mapping to decide single- vs cross-shard",
                    "The proposer of the current block",
                    "The mempool crate in Hyperscale-rs"
                ],
                correct: 1,
                explanation: "Shard assignment of NodeIDs is defined by the protocol or Radix Engine; the consensus layer uses it to decide single- vs cross-shard, but does not define the mapping itself."
            },
            {
                question: "For a cross-shard transaction, where does the tx (or sub-transactions) go after cross-shard determination?",
                options: [
                    "Only to the shard that owns the first NodeID in the tx",
                    "To the mempools of every shard that owns a touched NodeID",
                    "To a single global mempool that then forwards to shards at commit time",
                    "Only to the coordinator shard until step 13"
                ],
                correct: 1,
                explanation: "Single-shard: one mempool. Cross-shard: the tx or sub-transactions are enqueued in the mempools of every involved shard (step 5), and in step 6 they travel to each involved shard so each can order and process its part."
            },
            {
                question: "How is the proposer (block leader) chosen for a given round in a shard?",
                options: [
                    "Validators vote in a separate election phase before each block",
                    "Deterministically from the current view number and the shard's validator set (e.g. round-robin by index or validator identity)",
                    "The validator that received the most transactions in the previous round",
                    "Random selection weighted by stake"
                ],
                correct: 1,
                explanation: "Proposer selection is deterministic: e.g. proposer = validators[view % validators.len()] or by validator identity. Everyone agrees on the leader without extra messages."
            },
            {
                question: "In the BFT fault model used per shard, how many nodes are required for a quorum and what is the total node count?",
                options: [
                    "Quorum = f+1, total n = 2f+1 (CFT style)",
                    "Quorum = 2f+1, total n = 3f+1 (BFT: up to f Byzantine)",
                    "Quorum = 3f+1, total n = 4f+1",
                    "Quorum = majority, total n = any"
                ],
                correct: 1,
                explanation: "BFT uses n = 3f+1 nodes per shard; up to f can be Byzantine. A quorum is 2f+1 votes; any two quorums overlap in at least one honest node."
            },
            {
                question: "When does a block become final in this flow?",
                options: [
                    "After it is proposed (step 8)",
                    "After 2f+1 validators have voted and a QC is formed (step 10); BFT gives one-round finality, no reorg after QC",
                    "Only after step 13 (coordination) for cross-shard txs",
                    "After execution (step 12) when state is persisted"
                ],
                correct: 1,
                explanation: "Once a block has a quorum certificate (2f+1 votes from that shard's validators), it is final. BFT gives one-round finality; no reorg under normal BFT assumptions. Execution and persistence follow."
            },
            {
                question: "In step 13 (cross-shard coordination), when do shards make their state updates visible?",
                options: [
                    "During the prepare phase (lock/reserve and apply in the same round)",
                    "Only after the coordinator's decision (commit or abort), in an agreed order; prepare phase does not make state visible",
                    "Each shard applies as soon as it has voted yes, before the coordinator decides",
                    "Only the coordinator shard applies; others send results to it"
                ],
                correct: 1,
                explanation: "Prepare = lock/reserve, no visible state change yet. State updates happen only after the decision (commit or abort), in an agreed order (e.g. by shard ID or coordinator order), so every node sees the same composed outcome."
            },
            {
                question: "What happens in the prepare phase of cross-shard 2PC?",
                options: [
                    "Each shard commits its state change and then notifies the coordinator",
                    "Each shard runs its part (e.g. reserve/lock), does not make the state update visible yet, and replies yes or no to the coordinator",
                    "The coordinator locks all shards' state and then executes the tx itself",
                    "Validators on each shard vote on the block again"
                ],
                correct: 1,
                explanation: "Coordinator sends prepare to each involved shard. Each shard prepares (reserve/lock), does not make state visible, and replies yes or no. Only after all vote yes does the coordinator send commit; otherwise abort."
            },
            {
                question: "Why must state updates (commit or release) be applied in an 'agreed order' across shards in step 13?",
                options: [
                    "To minimize network messages",
                    "So every node sees the same composed outcome and no shard commits while another aborts; the protocol order ensures a single logical result",
                    "Because the coordinator can only send one message at a time",
                    "To allow rollback if a validator crashes"
                ],
                correct: 1,
                explanation: "Applying in an agreed order (e.g. by shard ID or coordinator order) ensures a single composed outcome everywhere and prevents one shard committing while another aborts ‚Äî that is what makes the cross-shard tx atomic and composable."
            }
        ];
        initializeQuiz('quiz-tx-flow', quizQuestions, 70);
    </script>
</body>
</html>
