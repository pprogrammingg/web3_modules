<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Exploring the Hyperscale-rs Codebase</title>
    <link rel="stylesheet" href="../shared/styles.css">
</head>
<body>
    <nav class="site-home-bar">
        <a href="../index.html" class="site-home-link" aria-label="Home">üè† Home</a>
    </nav>
    <div class="course-content">
        <div class="course-header">
            <h1>Exploring the Hyperscale-rs Codebase</h1>
            <div class="course-meta">
                <span>‚è±Ô∏è Duration: 1.5-2 hours</span>
                <span>üìä Difficulty: Basic</span>
                <span>üéØ Hyperscale-rs Specific</span>
            </div>
        </div>

        <div class="section">
            <h2>Learning Objectives</h2>
            <ul>
                <li>Navigate the codebase effectively</li>
                <li>Understand core types and traits</li>
                <li>Learn how NodeStateMachine works</li>
                <li>Read and understand Rust code patterns used in the project</li>
            </ul>
        </div>

        <div class="section">
            <h2>1. Where to Start</h2>
            <p>After cloning and building hyperscale-rs, the most useful entry points are:</p>
            <ul>
                <li><code>crates/core/src/lib.rs</code> ‚Äì re-exports core types and traits (<span data-glossary="state machine">StateMachine</span>, <span data-glossary="event-driven">Event</span>, <span data-glossary="event-driven">Action</span>)</li>
                <li><code>crates/core/src/traits.rs</code> ‚Äì <span data-glossary="state machine">StateMachine</span> trait definition</li>
                <li><code>crates/node/src/lib.rs</code> and <code>crates/node/src/state.rs</code> ‚Äì main <span data-glossary="state machine">NodeStateMachine</span> and how it composes sub‚Äìstate machines</li>
                <li><code>crates/types/</code> ‚Äì shared types (blocks, votes, hashes)</li>
            </ul>
            <p>Use <code>cargo doc --open</code> to generate and open API docs for the workspace; search for types and traits by name.</p>
        </div>

        <div class="section">
            <h2>2. Core Types and Traits</h2>
            <h3>StateMachine trait</h3>
            <p>Everything that participates in consensus implements the <span data-glossary="state machine">StateMachine</span> trait. In <code>crates/core/src/traits.rs</code> you'll see:</p>
            <div class="code-block"><pre><code class="language-rust">fn handle(&amp;mut self, event: Event) -&gt; Vec&lt;Action&gt;;
fn set_time(&amp;mut self, now: Duration);
fn now(&amp;self) -&gt; Duration;</code></pre></div>
            <p>Events flow in; actions flow out. Time is explicit for <span data-glossary="deterministic">determinism</span>.</p>
            <div class="info" style="margin-top: 0.75rem;">
                <strong>ü§î Think about it:</strong> Why pass <code>now</code> in from the outside instead of calling something like <code>SystemTime::now()</code> inside the state machine? What would break in tests or replay if the code read the real clock?
            </div>
            <h3>Event and Action enums</h3>
            <p>In <code>crates/core/src/event.rs</code> and <code>crates/core/src/action.rs</code> you'll see the full set of events (e.g. <code>BlockHeaderReceived</code>, <code>ProposalTimer</code>, <code>QuorumCertificateFormed</code>) and actions (e.g. <code>BroadcastToShard</code>, <code>SetTimer</code>, <code>CommitBlock</code>). Browsing these gives you a map of what the system can react to and what it can do.</p>
        </div>

        <div class="section">
            <h2>3. NodeStateMachine and Composition</h2>
            <p>The <strong>NodeStateMachine</strong> in <code>crates/node/src/state.rs</code> composes several sub‚Äìstate machines (BFT, execution, mempool, etc.). When an event arrives:</p>
            <ol>
                <li>The node routes the event to the appropriate sub‚Äìstate machine(s)</li>
                <li>Each returns a list of actions</li>
                <li>Actions are collected and executed by the runner (simulation or production)</li>
            </ol>
            <p>Open <code>crates/node/src/state.rs</code> and find the <code>handle</code> implementation. Trace one event type (e.g. <code>Event::BlockHeaderReceived</code>) to see which sub‚Äìmachines receive it and what actions they return.</p>
            <div class="info" style="margin-top: 0.75rem;">
                <strong>ü§î Check your understanding:</strong> If the node received two events at the same logical time, why would the *order* in which they're processed matter? (Think about proposer logic and votes.)
            </div>
        </div>

        <div class="section">
            <h2>4. Rust Patterns You'll See</h2>
            <ul>
                <li><strong>Enums for events/actions</strong> ‚Äì sum types with payloads; match on them to handle each case</li>
                <li><strong>No async in core</strong> ‚Äì consensus logic is synchronous; async lives in runners and I/O</li>
                <li><strong>Explicit time</strong> ‚Äì <code>set_time</code> / <code>now</code> so that tests and production use the same deterministic time</li>
                <li><strong>Pure functions</strong> ‚Äì <code>handle</code> takes state + event and returns actions; no hidden I/O</li>
            </ul>
        </div>

        <div class="section">
            <h2>5. Practical Exploration Tasks</h2>
            <div class="assignment">
                <h3>Tasks</h3>
                <ol>
                    <li>Run <code>cargo doc --open</code> and open the <code>core</code> and <code>node</code> crates. Find the <code>StateMachine</code> trait and the <code>NodeStateMachine</code> struct.</li>
                    <li>In <code>crates/node/src/state.rs</code>, find where <code>Event::ProposalTimer</code> or <code>Event::BlockHeaderReceived</code> is handled. Note which sub‚Äìstate machine(s) receive it.</li>
                    <li>In <code>crates/core/src/event.rs</code>, list three event variants and one field or associated type for each. Do the same for three action variants in <code>action.rs</code>.</li>
                    <li>In your learning journal, write one paragraph: ‚ÄúHow does the NodeStateMachine decide where to send an event?‚Äù (Use the code to support your answer.)</li>
                </ol>
                <h4>Success Criteria</h4>
                <ul>
                    <li>‚úÖ You can open the docs and find core types</li>
                    <li>‚úÖ You can trace one event through the node‚Äôs <code>handle</code> path</li>
                    <li>‚úÖ You can name several Event and Action variants and their role</li>
                </ul>
            </div>
        </div>

        <div class="section">
            <h2>6. Quiz</h2>
            <div id="quiz-02" class="quiz-container"></div>
        </div>

        <div class="navigation">
            <a href="module-01b-tx-flow.html" class="btn btn-secondary">‚Üê Previous Module</a>
            <button id="complete-module-btn" class="btn btn-primary">Mark as Complete</button>
            <a href="module-03-first-contribution.html" class="btn btn-primary">Next Module ‚Üí</a>
        </div>
    </div>

    <script src="../shared/course-data.js"></script>
    <script src="../shared/navigation.js"></script>
    <script src="../shared/glossary.js"></script>
    <script>
        initializeModulePage('basic-06');
        const quizQuestions = [
            {
                question: "Why does the StateMachine trait take time via set_time/now instead of reading the system clock?",
                options: [
                    "So tests and replays can control time ‚Äî same (state, event, time) always gives the same actions",
                    "To reduce dependencies and keep the core crate lightweight",
                    "Rust's std::time is not available in no_std environments used by consensus",
                    "So that different sub‚Äìstate machines can use different clocks"
                ],
                correct: 0,
                explanation: "Determinism requires that the same inputs always produce the same outputs. If the state machine read the clock internally, tests would be flaky and you couldn't replay a trace. Injecting time keeps the logic pure."
            },
            {
                question: "When NodeStateMachine receives an event, it routes to sub‚Äìstate machines and collects actions. What is a key downside if the node did not compose sub‚Äìmachines and instead handled everything in one big handle()?",
                options: [
                    "Rust would not compile code with a single large match",
                    "BFT, mempool, and execution would be tangled; testing and reasoning about each part in isolation would be much harder",
                    "The binary would be larger",
                    "Only one event type could be supported"
                ],
                correct: 1,
                explanation: "Composition keeps concerns separate: BFT handles consensus, mempool handles transaction pool, etc. Each can be tested in isolation; the node just routes and aggregates. A single monolithic handle would mix all of that and make contributions and debugging harder."
            },
            {
                question: "Where does async I/O (network, timers) live relative to the consensus state machine in hyperscale-rs?",
                options: [
                    "Inside the core and bft crates, which use tokio",
                    "In the runners (e.g. production, simulation): they do async I/O and translate to/from Event and Action; consensus remains synchronous",
                    "Only in the simulation crate, not in production",
                    "In the types crate, which defines async message types"
                ],
                correct: 1,
                explanation: "The core state machine is a pure function: state + event ‚áí actions. No awaits, no network calls. Runners do the async work and turn real-world events into Event and Action into real-world effects. That keeps consensus simple and deterministic."
            },
            {
                question: "You need to add a new Event variant that should trigger both BFT and mempool logic. Which set of changes is most accurate?",
                options: [
                    "Add the variant to Event in core; add a branch in the node's handle that sends it to both bft and mempool; implement handling in each of those crates",
                    "Add the variant only in the BFT crate, since BFT is the main component",
                    "Add it in event.rs and in CI so tests run twice",
                    "Add the variant in types/ and leave handle() unchanged so it is ignored"
                ],
                correct: 0,
                explanation: "Event defines the vocabulary in core; the node's handle shows which sub‚Äìmachine(s) get which event; each sub‚Äìmachine's handle implements the logic. To trigger both BFT and mempool you extend Event, route from the node to both, and implement in each crate."
            },
            {
                question: "In crates/node/src/state.rs, when the node receives Event::BlockHeaderReceived, what typically happens next (conceptually)?",
                options: [
                    "The node immediately writes the block to disk, then returns no actions",
                    "The event is routed to the relevant sub‚Äìstate machine(s); they return actions (e.g. vote, set timer); the runner will execute those actions",
                    "The node sends the block to the execution crate only",
                    "The event is converted to an Action and sent back to the network"
                ],
                correct: 1,
                explanation: "The node's handle() matches on event type, forwards to sub‚Äìmachines (e.g. BFT for block headers), collects their actions, and returns. The runner (simulation or production) is responsible for executing those actions (e.g. broadcasting, setting timers)."
            }
        ];
        initializeQuiz('quiz-02', quizQuestions, 70);
    </script>
</body>
</html>
