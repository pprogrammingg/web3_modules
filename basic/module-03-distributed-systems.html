<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Distributed Systems Fundamentals</title>
    <link rel="stylesheet" href="../shared/styles.css">
</head>
<body>
    <nav class="site-home-bar">
        <a href="../index.html" class="site-home-link" aria-label="Home">üè† Home</a>
    </nav>
    <div class="course-content">
        <div class="course-header">
            <h1>Distributed Systems Fundamentals</h1>
            <div class="course-meta">
                <span>‚è±Ô∏è Duration: 2-2.5 hours</span>
                <span>üìä Difficulty: Basic</span>
            </div>
        </div>

        <div class="section">
            <h2>Learning Objectives</h2>
            <ul>
                <li>Understand the <span data-glossary="cap theorem">CAP theorem</span> and its implications for blockchain</li>
                <li>Learn about network partitions and how systems respond (CP vs AP)</li>
                <li>Understand eventual vs strong consistency and why blockchains need strong consistency</li>
                <li>Understand <span data-glossary="partial synchrony">partial synchrony</span> and <span data-glossary="gst">GST (Global Stabilization Time)</span>‚Äîwhy BFT works despite <span data-glossary="flp impossibility">FLP (Fischer‚ÄìLynch‚ÄìPaterson impossibility)</span></li>
                <li>Distinguish <strong>safety</strong> vs <strong>liveness</strong> and how they trade off during partitions</li>
                <li>Understand <span data-glossary="quorum">quorum</span> intersection: why 3f+1 and 2f+1 guarantee agreement</li>
                <li>Learn leader-based consensus, <span data-glossary="view">view/round</span>, and why timeouts are needed for <span data-glossary="view change">view change</span></li>
                <li>Relate fault tolerance (crash vs Byzantine) to protocol design</li>
            </ul>
        </div>

        <div class="section">
            <h2>1. The CAP Theorem</h2>
            
            <h3>What is CAP?</h3>
            <p>In a distributed system you cannot have all three at once:</p>
            <ul>
                <li><strong>C ‚Äì Consistency</strong>: Every read sees the latest write (all nodes agree on the same data at the same time).</li>
                <li><strong>A ‚Äì Availability</strong>: Every request receives a response (no request is refused).</li>
                <li><strong>P ‚Äì Partition tolerance</strong>: The system keeps working even when the network splits (messages are dropped or delayed between groups of nodes).</li>
            </ul>
            <p>In practice, <strong>partition tolerance (P) is non-negotiable</strong>‚Äînetworks do partition. So the real choice is:</p>
            <ul>
                <li><strong>CP</strong>: When a partition happens, sacrifice availability‚Äîrefuse some requests until the partition heals so that consistency is preserved.</li>
                <li><strong>AP</strong>: When a partition happens, sacrifice consistency‚Äîkeep answering requests so both sides can diverge; you get eventual consistency.</li>
            </ul>
            <div class="info">
                <strong>Blockchains and CAP:</strong> Many blockchains are CP-oriented: they prefer consistency (one agreed chain) and may not make progress during severe partitions. Some designs relax this for liveness (availability of new blocks) under partial synchrony.
            </div>
        </div>

        <div class="section">
            <h2>2. Network Partitions</h2>
            
            <h3>What is a Partition?</h3>
            <p>A <strong>network partition</strong> is when the network splits into two or more groups that cannot communicate with each other. Messages between groups are lost or delayed indefinitely.</p>
            <h3>Why It Matters</h3>
            <p>During a partition, nodes in different groups cannot agree in real time. So:</p>
            <ul>
                <li><strong>CP systems</strong> may stop accepting writes (or block progress) in one or both sides until the partition heals, to avoid inconsistent state.</li>
                <li><strong>AP systems</strong> allow both sides to keep accepting operations; when the partition heals, they must merge or resolve conflicts (eventual consistency).</li>
            </ul>
            <p>BFT consensus assumes that eventually the network is synchronous enough (e.g. after <span data-glossary="gst">GST (Global Stabilization Time)</span>) so that a quorum can communicate. Until then, progress might stall (liveness), but safety (no two quorums commit different values) is preserved.</p>
        </div>

        <div class="section">
            <h2>3. Eventual Consistency vs Strong Consistency</h2>
            
            <h3>Strong Consistency</h3>
            <p>Every read sees the result of the latest completed write. All nodes agree on the same order and value. This is what <span data-glossary="consensus">consensus</span> and BFT aim for: one agreed sequence of blocks.</p>
            <h3>Eventual Consistency</h3>
            <p>If no new writes are made, eventually all nodes will converge to the same state. Before that, different nodes might see different data. Used in many AP systems (e.g. Dynamo-style, CRDTs).</p>
            <h3>In Blockchain</h3>
            <p>Blockchains typically want <strong>strong consistency</strong> on the canonical chain: once a block is committed (e.g. via BFT), all honest nodes agree. Nakamoto consensus gives <em>probabilistic</em> agreement (longest chain); BFT gives <em>deterministic</em> agreement.</p>
        </div>

        <div class="section">
            <h2>4. Fault Tolerance</h2>
            
            <h3>Failure Modes</h3>
            <ul>
                <li><strong>Crash</strong>: A node stops responding (no malicious behavior).</li>
                <li><strong>Byzantine</strong>: A node can behave arbitrarily (delay, drop, or send conflicting messages). BFT protocols tolerate up to f Byzantine nodes out of 3f+1.</li>
                <li><strong>Omission</strong>: Messages are dropped (can be modeled as crash or network partition).</li>
            </ul>
            <h3>Why It Matters for hyperscale-rs</h3>
            <p>Hyperscale-rs uses BFT consensus, so it is designed to tolerate Byzantine faults (up to 1/3 of validators). Understanding partitions and CAP helps you see why the protocol may not make progress during a partition (CP-style), and why quorum sizes (2f+1) are chosen so that any two quorums overlap in at least one honest node.</p>
        </div>

        <div class="section">
            <h2>5. Partial Synchrony and <span data-glossary="gst">GST (Global Stabilization Time)</span></h2>
            <p>The <span data-glossary="flp impossibility">FLP (Fischer‚ÄìLynch‚ÄìPaterson) impossibility</span> result says: in a fully <strong>asynchronous</strong> network, deterministic consensus cannot guarantee <strong>termination</strong> if even one node can fail. What does that mean in plain terms?</p>
            <ul>
                <li><strong>Fully asynchronous:</strong> There is no bound on how long messages take to arrive. You can never tell whether a node is slow, the network is delayed, or a message was lost. So you can't safely assume "after 5 seconds, if I got no reply, the node is dead."</li>
                <li><strong>Cannot guarantee termination:</strong> The protocol might never "decide"‚Äîi.e. never output a final agreed value. The nodes might keep exchanging messages forever without reaching consensus. FLP proves that this is unavoidable in the asynchronous model if one node can crash.</li>
                <li><strong>If even one node can fail:</strong> The result holds with just one crash fault (a node that stops responding). It doesn't require Byzantine (malicious) behavior.</li>
            </ul>
            <p>So how do BFT blockchains work? They <em>relax the model</em>: they assume the network is not fully asynchronous forever. That's where <strong>partial synchrony</strong> comes in.</p>
            <h3><span data-glossary="partial synchrony">Partial synchrony</span></h3>
            <p>BFT protocols assume <strong>partial synchrony</strong>: the network is asynchronous until some unknown point, called <strong><span data-glossary="gst">GST (Global Stabilization Time)</span></strong>. After <span data-glossary="gst">GST</span>, message delays are bounded by a known Œî. We don't know when <span data-glossary="gst">GST</span> is‚Äîonly that it eventually happens.</p>
            <ul>
                <li><strong>Before <span data-glossary="gst">GST</span>:</strong> The protocol may not make progress (liveness at risk), but it must not commit conflicting values (safety preserved).</li>
                <li><strong>After <span data-glossary="gst">GST</span>:</strong> Timeouts and retries eventually allow a quorum to communicate, so the protocol can make progress.</li>
            </ul>
            <div class="info">
                <strong>Why this matters for Hyperscale:</strong> The BFT crate assumes eventual synchrony. During a partition or bad network, you may see no new blocks (liveness); once the network recovers (<span data-glossary="gst">GST (Global Stabilization Time)</span> has passed), the protocol resumes. This is the standard assumption for HotStuff-style consensus.
            </div>
        </div>

        <div class="section">
            <h2>6. Safety vs Liveness</h2>
            <p>Consensus protocols aim for two guarantees:</p>
            <ul>
                <li><strong>Safety:</strong> No two honest nodes ever commit different values (e.g. different blocks at the same height). Once committed, it's final.</li>
                <li><strong>Liveness:</strong> The system eventually makes progress‚Äînew blocks keep being committed (assuming at most f faults and, for most BFT, partial synchrony).</li>
            </ul>
            <p>Under a partition, you typically <strong>preserve safety</strong> (no conflicting commits) but may <strong>lose liveness</strong> (no progress until the partition heals). BFT designs prioritize safety: they would rather stall than allow two quorums to commit different blocks.</p>
            <div class="info">
                <strong>In Hyperscale:</strong> Steps 7‚Äì11 in the transaction flow (proposer ‚Üí vote ‚Üí QC ‚Üí commit) can stall during a partition; when the network recovers, the same protocol continues and no honest node has committed a conflicting block.
            </div>
        </div>

        <div class="section">
            <h2>7. Quorum Intersection: Why 3f+1 and 2f+1</h2>
            <p>In BFT with <strong>n = 3f + 1</strong> nodes, a <span data-glossary="quorum">quorum</span> is any set of <strong>2f + 1</strong> nodes. The crucial property:</p>
            <p><strong>Any two quorums intersect in at least one honest node.</strong></p>
            <ul>
                <li>There are at most f Byzantine nodes. So there are at least 2f+1 honest nodes.</li>
                <li>Any set of 2f+1 nodes (a quorum) must contain at least (2f+1) ‚àí f = f+1 honest nodes.</li>
                <li>Two different quorums (each of size 2f+1) have at most 2f nodes total outside their intersection. So they share at least (2f+1) + (2f+1) ‚àí (3f+1) = 2f+1 ‚àí f = f+1 nodes. At least one of those must be honest (since at most f are Byzantine). So <em>any two quorums share at least one honest node</em>.</li>
            </ul>
            <p>Consequence: if one quorum commits block A and another commits block B (A ‚â† B), they would need to share an honest node that voted for both‚Äîbut an honest node votes only for one value. So <strong>two different blocks cannot both get a quorum</strong>. That's the core of BFT safety.</p>
        </div>

        <div class="section">
            <h2>8. Leader-Based Consensus: View, Round, and Timeouts</h2>
            <p>BFT protocols like HotStuff are <strong>leader-based</strong>: in each <span data-glossary="view">view</span> (or round), one node‚Äîthe <strong>proposer/leader</strong>‚Äîis designated to propose a block. Validators then vote; when 2f+1 vote, a QC is formed. For the exact steps (i)‚Äì(v) of how a QC is formed and how it is carried in the next block, plus crate and line references in hyperscale-rs, see <a href="module-02-consensus-basics.html">Consensus Algorithms: From Basics to BFT</a>, section ‚ÄúHow a QC is formed‚Äù.</p>
            <h3>What if the leader is faulty or partitioned?</h3>
            <p>If the leader doesn't send a block, or validators don't receive it, the round would never finish. So protocols use <strong>timeouts</strong>: if no QC is formed within some time bound (after <span data-glossary="gst">GST (Global Stabilization Time)</span>), nodes assume the leader is faulty and move to the <strong>next view</strong>, where a new leader (chosen deterministically, e.g. round-robin) proposes. This is a <span data-glossary="view change">view change</span>.</p>
            <ul>
                <li><strong>Why time?</strong> Liveness requires progress; without a timeout, a faulty leader could stall the system forever. Partial synchrony (bounded delay after <span data-glossary="gst">GST (Global Stabilization Time)</span>) makes timeouts meaningful.</li>
                <li><strong>Implicit vs coordinated:</strong> In HotStuff-2, view change is <span data-glossary="implicit view change">implicit</span>‚Äîon timeout, the next leader simply proposes; no separate view-change vote. <span data-glossary="pbft">PBFT</span> uses an explicit coordinated view-change phase.</li>
            </ul>
        </div>

        <div class="section">
            <h2>9. Why This Matters for Hyperscale-rs</h2>
            <p>When you read the Hyperscale-rs codebase or the <strong>Transaction Flow</strong> module:</p>
            <ul>
                <li><strong>CAP &amp; partitions:</strong> The system is CP-oriented; during a partition it may not produce new blocks (no availability), but it won't commit conflicting blocks (consistency).</li>
                <li><strong>Partial synchrony:</strong> The BFT crate assumes the network eventually obeys bounds; timeouts and round advancement depend on that.</li>
                <li><strong>Safety vs liveness:</strong> The commit rule (e.g. two-chain) and quorum intersection ensure safety; view changes and timeouts aim for liveness.</li>
                <li><strong>Quorum size 2f+1:</strong> Votes and QCs use this threshold so that any two quorums overlap in an honest node‚Äîthis is why the protocol is safe.</li>
            </ul>
        </div>

        <div class="section">
            <h2>10. Key Takeaways</h2>
            <ul>
                <li>CAP: under partitions, you trade off consistency (CP) vs availability (AP); blockchains typically choose CP.</li>
                <li><span data-glossary="partial synchrony">Partial synchrony</span> (<span data-glossary="gst">GST (Global Stabilization Time)</span>) is the assumption that lets BFT bypass <span data-glossary="flp impossibility">FLP (Fischer‚ÄìLynch‚ÄìPaterson impossibility)</span>: after some unknown time, the network is "good enough" for progress.</li>
                <li>Safety = no conflicting commits; liveness = eventual progress. During partitions, safety is preserved, liveness may be lost.</li>
                <li>Quorum intersection (3f+1, 2f+1): any two quorums share an honest node, so they cannot commit different values.</li>
                <li>Leader-based BFT uses views/rounds and timeouts for view change when the leader is faulty or partitioned.</li>
                <li>Fault tolerance (crash vs Byzantine) determines protocol design (2f+1 vs 3f+1, and whether we need quorum intersection).</li>
            </ul>
        </div>

        <div class="section">
            <h2>11. Quiz</h2>
            <div id="quiz-03" class="quiz-container"></div>
        </div>

        <div class="section">
            <h2>12. Practical Assignment</h2>
            <div class="assignment">
                <h3>Assignment: Distributed Systems and BFT</h3>
                <ol>
                    <li>In one paragraph, explain why a distributed system cannot guarantee consistency, availability, and partition tolerance at the same time. Give one CP and one AP example.</li>
                    <li>Explain in your own words: what is partial synchrony (<span data-glossary="gst">GST (Global Stabilization Time)</span>), and why does it allow BFT to guarantee both safety and liveness despite the <span data-glossary="flp impossibility">FLP (Fischer‚ÄìLynch‚ÄìPaterson) impossibility</span> result?</li>
                    <li>State the quorum intersection property (why any two quorums of 2f+1 in a 3f+1 system share an honest node). In one sentence, why does this guarantee that two different blocks cannot both be committed?</li>
                    <li>During a network partition, does a BFT system typically preserve safety, liveness, or both? Briefly explain.</li>
                    <li>In your learning journal, note how Hyperscale-rs (or the transaction flow) reflects: CAP choice, partial synchrony, safety vs liveness, and quorum size.</li>
                </ol>
                <h4>Success Criteria:</h4>
                <ul>
                    <li>‚úÖ You can explain CAP, partial synchrony, and safety vs liveness</li>
                    <li>‚úÖ You understand quorum intersection and why 3f+1 / 2f+1</li>
                    <li>‚úÖ You can relate these concepts to BFT and Hyperscale-rs</li>
                </ul>
            </div>
        </div>

        <div class="navigation">
            <a href="module-02-consensus-basics.html" class="btn btn-secondary">‚Üê Previous Module</a>
            <button id="complete-module-btn" class="btn btn-primary">Mark as Complete</button>
            <a href="module-04-state-machines.html" class="btn btn-primary">Next Module ‚Üí</a>
        </div>
    </div>

    <script src="../shared/course-data.js"></script>
    <script src="../shared/navigation.js"></script>
    <script src="../shared/glossary.js"></script>
    <script>
        initializeModulePage('basic-03');

        const quizQuestions = [
            {
                question: "In CAP, when a network partition occurs, what is the practical choice?",
                options: [
                    "Keep both C and A and give up P",
                    "Keep P and choose either CP or AP",
                    "Keep C and A and give up P",
                    "There is no choice"
                ],
                correct: 1
            },
            {
                question: "What does 'eventual consistency' mean?",
                options: [
                    "Data is always consistent immediately",
                    "If writes stop, all nodes eventually converge to the same state",
                    "Only one node can write at a time",
                    "Data is never consistent"
                ],
                correct: 1
            },
            {
                question: "In BFT with n = 3f+1 nodes, how many nodes can be Byzantine and the system still be safe?",
                options: [
                    "Up to 2f+1",
                    "Up to f",
                    "Up to 1",
                    "Zero"
                ],
                correct: 1
            },
            {
                question: "Why is partition tolerance (P) often considered non-negotiable?",
                options: [
                    "Because users demand it",
                    "Because networks can and do partition in practice",
                    "Because consistency is unimportant",
                    "Because availability is unimportant"
                ],
                correct: 1
            },
            {
                question: "What does partial synchrony (GST = Global Stabilization Time) assume?",
                options: [
                    "The network is always synchronous",
                    "After some unknown time (GST), message delays are bounded",
                    "Messages are never lost",
                    "There are no Byzantine nodes"
                ],
                correct: 1
            },
            {
                question: "During a network partition, what does BFT typically preserve?",
                options: [
                    "Liveness only",
                    "Safety only",
                    "Both safety and liveness",
                    "Neither"
                ],
                correct: 1
            },
            {
                question: "Why can two different blocks not both get a quorum in BFT (n = 3f+1, quorum 2f+1)?",
                options: [
                    "Because only one block is proposed per round",
                    "Any two quorums share at least one honest node, who would not vote for both",
                    "Because the network is synchronous",
                    "Because validators are paid to agree"
                ],
                correct: 1
            },
            {
                question: "Why do BFT protocols use timeouts for view/round advancement?",
                options: [
                    "To reduce message size",
                    "To ensure liveness: a faulty or partitioned leader cannot stall progress forever",
                    "To improve signature aggregation",
                    "To guarantee safety"
                ],
                correct: 1
            }
        ];

        initializeQuiz('quiz-03', quizQuestions, 70);
    </script>
</body>
</html>
