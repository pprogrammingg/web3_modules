<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Module 1.2: Consensus Algorithms - From Basics to BFT</title>
    <link rel="stylesheet" href="../shared/styles.css">
</head>
<body>
    <nav class="site-home-bar">
        <a href="../index.html" class="site-home-link" aria-label="Home">üè† Home</a>
    </nav>
    <div class="course-content">
        <div class="course-header">
            <h1>Module 1.2: Consensus Algorithms - From Basics to BFT</h1>
            <div class="course-meta">
                <span>‚è±Ô∏è Duration: 1.5-2 hours</span>
                <span>üìä Difficulty: Basic</span>
                <span>üìÖ Month 1, Week 2</span>
            </div>
        </div>

        <div class="section">
            <h2>Learning Objectives</h2>
            <ul>
                <li>Understand the consensus problem in distributed systems</li>
                <li>Learn about Byzantine Fault Tolerance (BFT)</li>
                <li>Understand quorum certificates and voting</li>
                <li>Learn the basics of HotStuff-2 protocol</li>
                <li>Compare BFT with <span data-glossary="proof of stake">Proof-of-Stake (PoS)</span></li>
            </ul>
        </div>

        <div class="section">
            <h2>1. The Consensus Problem</h2>
            
            <h3>What is Consensus?</h3>
            <p>In a distributed system, <strong><span data-glossary="consensus">consensus</span></strong> is the process of getting all honest nodes to agree on a single value or sequence of values, even when some nodes may be faulty or malicious.</p>

            <div class="info">
                <strong>Example:</strong> Imagine 4 generals trying to coordinate an attack. One might be a traitor. How do the honest generals agree on a plan?
            </div>

            <h3>Why is Consensus Hard?</h3>
            <ul>
                <li><strong>Network delays</strong> - Messages arrive at different times</li>
                <li><strong>Node failures</strong> - Nodes can crash or go offline</li>
                <li><strong><span data-glossary="byzantine fault">Byzantine faults</span></strong> - Nodes can lie, send conflicting messages, or behave arbitrarily</li>
                <li><strong>Network partitions</strong> - Network can split into isolated groups</li>
            </ul>

            <h3>The <span data-glossary="flp impossibility">FLP Impossibility</span> Result</h3>
            <p>Fischer, Lynch, and Paterson proved that in an asynchronous network, it's <strong>impossible</strong> to guarantee consensus if even one node can fail. This is why blockchain systems make assumptions about network synchrony.</p>
        </div>

        <div class="section">
            <h2>2. Byzantine Fault Tolerance (BFT)</h2>
            
            <h3>What is BFT?</h3>
            <p><strong><span data-glossary="bft">Byzantine Fault Tolerance</span></strong> is the ability of a system to function correctly even when some nodes are Byzantine (malicious or faulty).</p>

            <h3>Fault Model</h3>
            <p>In a BFT system with <strong>n = 3f + 1</strong> nodes:</p>
            <ul>
                <li>Up to <strong>f</strong> nodes can be Byzantine (malicious)</li>
                <li>At least <strong>2f + 1</strong> nodes must be honest</li>
                <li>This ensures any two <span data-glossary="quorum">quorums</span> (groups of 2f+1) must overlap in at least one honest node</li>
            </ul>

            <div class="code-block"><pre><code>Example: n = 4, f = 1
- Total nodes: 4
- Byzantine nodes: up to 1
- Honest nodes: at least 3
- Quorum size: 2f + 1 = 3

Any two groups of 3 nodes must share at least 1 honest node.</code></pre></div>

            <h3>BFT vs <span data-glossary="crash fault">Crash Fault</span> Tolerance (CFT)</h3>
            <table style="width: 100%; border-collapse: collapse; margin: 1rem 0;">
                <tr style="background: var(--bg-secondary);">
                    <th style="padding: 0.5rem; border: 1px solid var(--border-color);">Aspect</th>
                    <th style="padding: 0.5rem; border: 1px solid var(--border-color);">CFT</th>
                    <th style="padding: 0.5rem; border: 1px solid var(--border-color);">BFT</th>
                </tr>
                <tr>
                    <td style="padding: 0.5rem; border: 1px solid var(--border-color);">Fault Model</td>
                    <td style="padding: 0.5rem; border: 1px solid var(--border-color);">Nodes crash</td>
                    <td style="padding: 0.5rem; border: 1px solid var(--border-color);">Nodes can be malicious</td>
                </tr>
                <tr>
                    <td style="padding: 0.5rem; border: 1px solid var(--border-color);">Tolerance</td>
                    <td style="padding: 0.5rem; border: 1px solid var(--border-color);">f out of 2f+1</td>
                    <td style="padding: 0.5rem; border: 1px solid var(--border-color);">f out of 3f+1</td>
                </tr>
                <tr>
                    <td style="padding: 0.5rem; border: 1px solid var(--border-color);">Use Case</td>
                    <td style="padding: 0.5rem; border: 1px solid var(--border-color);">Databases, distributed systems</td>
                    <td style="padding: 0.5rem; border: 1px solid var(--border-color);">Blockchains, critical systems</td>
                </tr>
            </table>
        </div>

        <div class="section">
            <h2>3. Quorum Certificates (QCs)</h2>
            
            <h3>What is a Quorum Certificate?</h3>
            <p>A <strong><span data-glossary="quorum certificate">Quorum Certificate (QC)</span></strong> is cryptographic proof that at least 2f+1 validators have voted for a block. It's an aggregated signature from a <span data-glossary="quorum">quorum</span> of validators.</p>

            <h3>Properties of QCs</h3>
            <ul>
                <li><strong>Cryptographic proof</strong> - Cannot be forged</li>
                <li><strong>Compact</strong> - Single aggregated signature (not 2f+1 individual signatures)</li>
                <li><strong>Verifiable</strong> - Anyone can verify the QC</li>
                <li><strong>Binding</strong> - Proves agreement on a specific block</li>
            </ul>

            <h3>How a QC is Formed ‚Äì Steps</h3>
            <p>In HotStuff-style BFT, a quorum certificate is produced and then carried in the next block‚Äôs header. Conceptually:</p>
            <ol style="list-style-type: none; padding-left: 0;">
                <li><strong>(i)</strong> The proposer for block H builds the block (including <code>parent_qc</code> = QC for H‚àí1 in the header) and broadcasts the block header to the shard.</li>
                <li><strong>(ii)</strong> Validators receive the header, validate it, and each signs a vote (block hash + metadata). Votes are broadcast to the shard (so every validator, including the next proposer, receives them).</li>
                <li><strong>(iii)</strong> When any validator has 2f+1 valid votes for block H, it requests aggregation into a single QC (verify signatures and build aggregated signature). That node‚Äôs state stores the new QC as its <code>latest_qc</code>.</li>
                <li><strong>(iv)</strong> The QC is not sent as a separate network message. The next proposer (for H+1) either formed QC(H) locally from the broadcast votes, or later sees QC(H) when it receives a block whose header contains it.</li>
                <li><strong>(v)</strong> When the next proposer builds block H+1, it sets the new header‚Äôs <code>parent_qc</code> = QC(H) (from its <code>latest_qc</code>) and broadcasts block H+1. All validators then see QC(H) inside the header of H+1.</li>
            </ol>
            <p>So: votes are broadcast ‚Üí (any) validator with 2f+1 votes forms the QC locally ‚Üí QC is carried in the next block‚Äôs header.</p>

            <h4>Communication flow (matches (i)‚Äì(v) above)</h4>
            <div class="block-diagram">
                <div class="diagram-block">
                    <div class="block-header">
                        <div class="block-title">(i) Block H proposal</div>
                        <div class="block-field">- Proposer builds block H (header has parent_qc = QC(H‚àí1)), broadcasts header</div>
                    </div>
                </div>
                <div class="diagram-arrow">‚Üì</div>
                <div class="diagram-label">(ii) Validators receive &amp; validate; votes broadcast to shard</div>
                <div class="diagram-arrow">‚Üì</div>
                <div class="diagram-label">(iii) When 2f+1 votes: request QC build ‚Üí latest_qc updated</div>
                <div class="diagram-arrow">‚Üì</div>
                <div class="diagram-block">
                    <div class="block-header">
                        <div class="block-title">(iv)‚Äì(v) Block H+1</div>
                        <div class="block-field">- Next proposer sets parent_qc = QC(H), broadcasts H+1</div>
                        <div class="block-field">- All validators see QC(H) in H+1‚Äôs header</div>
                    </div>
                </div>
            </div>

            <div class="info" style="margin-top: 1.5rem;">
                <strong>Key point:</strong> The QC is not broadcast as a separate message. Votes are broadcast; validators with 2f+1 votes form the QC locally; the next block‚Äôs header carries that QC as <code>parent_qc</code>, so everyone sees it when they receive the next block.
            </div>

            <h4>Example timeline</h4>
            <div class="code-block"><pre><code>T1: Proposer builds Block 10 (header includes QC for Block 9), broadcasts header
T2: Validators validate, sign votes, broadcast votes to shard
T3: When 2f+1 votes received ‚Üí any such validator requests QC build ‚Üí QC(10) formed, stored as latest_qc
T4: Next proposer builds Block 11 with parent_qc = QC(10), broadcasts Block 11
T5: All nodes receive Block 11 ‚Üí see QC(10) in header</code></pre></div>

            <h4>In hyperscale-rs (crate and line references)</h4>
            <ul>
                <li><strong>(i)</strong> Block header carries <code>parent_qc</code>: <code>crates/types/src/block.rs</code> (struct <code>BlockHeader</code>, field <code>parent_qc</code> at line 75).</li>
                <li><strong>(ii)</strong> Votes are broadcast to the shard: <code>Action::PersistAndBroadcastVote</code> in <code>crates/core/src/action.rs</code> (lines 444‚Äì449). BFT state emits it when a validator votes: <code>crates/bft/src/state.rs</code> (around line 2575).</li>
                <li><strong>(iii)</strong> When 2f+1 votes are collected, state requests <code>Action::VerifyAndBuildQuorumCertificate</code>: <code>crates/core/src/action.rs</code> (lines 113‚Äì132), emitted from <code>crates/bft/src/state.rs</code> (around line 2765). Runner performs verification/aggregation; BFT‚Äôs <code>vote_set</code> builds the QC: <code>crates/bft/src/vote_set.rs</code> (<code>build_qc</code> at line 307). When the QC is ready, <code>on_qc_formed</code> in <code>crates/bft/src/state.rs</code> sets <code>self.latest_qc = Some(qc)</code> (line 3583).</li>
                <li><strong>(iv)</strong> No separate QC message: validators (including the next proposer) either form the QC from broadcast votes or later set <code>latest_qc</code> from a received block header: <code>crates/bft/src/state.rs</code> (e.g. <code>self.latest_qc = Some(header.parent_qc.clone())</code> at line 1597).</li>
                <li><strong>(v)</strong> Building the next block uses <code>self.latest_qc</code> as <code>parent_qc</code>: <code>crates/bft/src/state.rs</code> (e.g. lines 1013‚Äì1017, 1147, 1182‚Äì1208, 1296‚Äì1323).</li>
            </ul>
            <p>References are to the <a href="https://github.com/flightofthefox/hyperscale-rs" target="_blank" rel="noopener">hyperscale-rs</a> repo (paths and line numbers may shift slightly with upstream).</p>
        </div>

        <div class="section">
            <h2>4. HotStuff-2 Protocol Basics</h2>
            
            <h3>What is HotStuff-2?</h3>
            <p><strong>HotStuff-2</strong> is a <span data-glossary="bft">BFT</span> consensus protocol that uses a <span data-glossary="two-chain commit">two-chain commit</span> rule. It's an improvement over traditional BFT protocols like <span data-glossary="pbft">PBFT</span>.</p>

            <h3>What is <span data-glossary="pbft">PBFT</span>?</h3>
            <p><strong><span data-glossary="pbft">PBFT (Practical Byzantine Fault Tolerance)</span></strong> is a classic BFT consensus protocol introduced by Castro and Liskov in 1999. It was one of the first practical BFT protocols that could handle Byzantine faults in asynchronous networks.</p>
            
            <h4>PBFT Characteristics:</h4>
            <ul>
                <li><strong>Three-phase commit</strong> - Requires three rounds of communication (pre-prepare, prepare, commit)</li>
                <li><strong>Three-chain commit rule</strong> - A block only commits after three consecutive blocks have QCs (quorum certificates)</li>
                <li><strong>Coordinated view changes</strong> - When the leader is suspected of being faulty, all nodes coordinate to vote on a new leader/view</li>
                <li><strong>Quadratic communication</strong> - O(n¬≤) messages per block (each node sends messages to all other nodes)</li>
                <li><strong>Explicit view-change protocol</strong> - Requires a separate voting phase to change views/leaders</li>
            </ul>

            <div class="info">
                <strong>Why <span data-glossary="pbft">PBFT</span> matters:</strong> <span data-glossary="pbft">PBFT</span> established the foundation for BFT consensus. Many modern protocols (including HotStuff-2) are improvements on PBFT's core ideas, addressing its limitations around communication complexity and view changes.
            </div>

            <h3>Key Features of HotStuff-2</h3>
            <ul>
                <li><strong><span data-glossary="two-chain commit">Two-chain commit</span></strong> - Block commits when next block gets <span data-glossary="qc">QC</span> (vs <span data-glossary="three-chain commit">3-chain</span> in <span data-glossary="pbft">PBFT</span>)
                    <div class="highlight" style="margin-top: 0.5rem; margin-left: 1rem;">
                        <strong>What this means:</strong> In <span data-glossary="pbft">PBFT</span>, you need blocks at heights H, H+1, and H+2 to all have <span data-glossary="qc">QCs</span> before H commits (<span data-glossary="three-chain commit">three-chain commit</span>). In HotStuff-2, you only need H and H+1 to have <span data-glossary="qc">QCs</span>. This reduces latency from 3 blocks to 2 blocks.
                    </div>
                </li>
                <li><strong><span data-glossary="implicit view change">Implicit view changes</span></strong> - No <span data-glossary="coordinated view-change">coordinated view-change voting</span>
                    <div class="highlight" style="margin-top: 0.5rem; margin-left: 1rem;">
                        <strong>What "<span data-glossary="coordinated view-change">coordinated view-change voting</span>" means:</strong> In <span data-glossary="pbft">PBFT</span>, when nodes suspect the leader is faulty, they must coordinate a <span data-glossary="view change">view-change</span>. This requires:
                        <ul style="margin-top: 0.5rem;">
                            <li>All nodes detecting the problem</li>
                            <li>A voting phase where nodes vote to change the view</li>
                            <li>Agreement on the new leader</li>
                            <li>State synchronization before resuming normal operation</li>
                        </ul>
                        This is complex and can cause delays. HotStuff-2 uses <strong><span data-glossary="implicit view change">implicit view changes</span></strong> - if a block doesn't get a <span data-glossary="qc">QC</span> within a timeout, nodes automatically advance to the next view/leader without explicit voting. The next leader simply proposes the next block, and if it gets a <span data-glossary="qc">QC</span>, the <span data-glossary="view change">view change</span> is implicitly accepted.
                    </div>
                </li>
                <li><strong>Optimistic pipelining</strong> - Multiple blocks can be in-flight</li>
                <li><strong>Linear communication</strong> - O(n) messages per block (vs O(n¬≤) in <span data-glossary="pbft">PBFT</span>)
                    <div class="highlight" style="margin-top: 0.5rem; margin-left: 1rem;">
                        <strong>Communication complexity:</strong> In <span data-glossary="pbft">PBFT</span>, each node sends messages to all other nodes, resulting in n √ó n = n¬≤ messages. HotStuff-2 uses a leader-based approach where nodes only send messages to the leader, resulting in n messages per block.
                    </div>
                </li>
            </ul>

            <h3>Basic Flow</h3>
            <ol>
                <li><strong>Proposal</strong>: Proposer creates and broadcasts block header</li>
                <li><strong>Voting</strong>: Validators validate and vote</li>
                <li><strong>QC Formation</strong>: When 2f+1 votes collected, QC is formed</li>
                <li><strong>Commit</strong>: Block commits when next block gets QC (two-chain rule)</li>
            </ol>

            <h3>Two-Chain Commit Rule</h3>
            <p>Block at height H commits when block at height H+1 gets a QC.</p>
            <div class="code-block"><pre><code>Rule: Block H commits when block H+1 receives a QC.

Example scenario:
1. Block H is proposed and receives QC
2. Block H+1 is proposed and receives QC
   ‚Üí Block H NOW COMMITS (because H+1 has QC)
3. Block H+2 is proposed and receives QC
   ‚Üí Block H+1 NOW COMMITS (because H+2 has QC)

Visual representation:
Block H:    [has QC] ‚Üí commits when H+1 gets QC ‚úì
Block H+1:  [has QC] ‚Üí commits when H+2 gets QC (waiting...)
Block H+2:  [no QC yet] ‚Üí will commit when H+3 gets QC (waiting...)

The "two-chain" name comes from needing 2 consecutive blocks with QCs:
- H has QC and H+1 has QC ‚Üí H commits (2 blocks in chain)</code></pre></div>

            <div class="success">
                <strong>Why Two-Chain?</strong> Ensures <span data-glossary="finality">finality</span> even under network partitions. Only one chain can get consecutive QCs.
                
                <div style="margin-top: 1rem; padding-top: 1rem; border-top: 1px solid rgba(16, 185, 129, 0.3);">
                    <strong>Understanding Finality:</strong>
                    <p style="margin-top: 0.5rem;"><strong><span data-glossary="finality">Finality</span></strong> means once a block is committed, it cannot be reverted. In two-chain commit: Block H commits when H+1 gets a <span data-glossary="qc">QC</span>, creating a chain of QCs proving agreement by 2f+1 validators.</p>
                    <p style="margin-top: 0.5rem;">Under network partitions, only the majority partition (2f+1 validators) can produce consecutive QCs. The minority cannot, so their blocks won't commit. This ensures <strong>safety</strong>: only one valid chain exists, and committed blocks are permanent.</p>
                </div>
            </div>
        </div>

        <div class="section">
            <h2>5. What PoW and BFT Mean (and How They Relate)</h2>
            
            <p><strong>BFT</strong> and <strong><span data-glossary="proof of work">Proof of Work (PoW)</span></strong> answer different questions:</p>
            <ul>
                <li><strong>BFT</strong> is a <em>consensus</em> approach: <em>how</em> do nodes agree on the next block? In BFT, a fixed (or known) set of validators vote; once a quorum agrees, the block is committed. So BFT = agreement by voting among identified participants.</li>
                <li><strong>PoW</strong> is a <em>participation / block-producer selection</em> mechanism: <em>who</em> gets to propose the next block? In PoW, miners compete by solving a puzzle; the winner proposes. The chain then uses the <em>longest-chain rule</em> (Nakamoto consensus), not BFT voting. So PoW = who may extend the chain, plus probabilistic agreement via ‚Äúlongest chain wins.‚Äù</li>
            </ul>
            <p><strong>How they relate:</strong> BFT and PoW are on different axes. BFT is about the <em>agreement rule</em> (voting, quorums, deterministic finality). PoW (and <span data-glossary="proof of stake">PoS</span>) are about <em>who participates</em> or who gets to propose. Many chains use <strong>BFT for agreement</strong> and <strong>PoS for validator selection</strong> (e.g. Tendermint: BFT consensus + PoS to choose the validator set). PoW chains typically do <em>not</em> use BFT; they use Nakamoto (longest-chain) consensus with probabilistic finality.</p>

            <h3>BFT vs Proof-of-Stake (PoS)</h3>
            
            <p>Below compares <strong>classic BFT</strong> (fixed validator set, as in Hyperscale-rs) with <strong>open PoS</strong> (anyone can join by staking). Many chains combine both (e.g. Tendermint: BFT consensus + PoS for validator selection).</p>
            
            <h3>Key Differences</h3>
            <table style="width: 100%; border-collapse: collapse; margin: 1rem 0;">
                <tr style="background: var(--bg-secondary);">
                    <th style="padding: 0.5rem; border: 1px solid var(--border-color); text-align: center;">Aspect</th>
                    <th style="padding: 0.5rem; border: 1px solid var(--border-color); text-align: center;">BFT (classic)</th>
                    <th style="padding: 0.5rem; border: 1px solid var(--border-color); text-align: center;">PoS (open)</th>
                </tr>
                <tr>
                    <td style="padding: 0.5rem; border: 1px solid var(--border-color);">Validator Set</td>
                    <td style="padding: 0.5rem; border: 1px solid var(--border-color); text-align: center;">Fixed, known</td>
                    <td style="padding: 0.5rem; border: 1px solid var(--border-color); text-align: center;">Dynamic, stake-weighted</td>
                </tr>
                <tr>
                    <td style="padding: 0.5rem; border: 1px solid var(--border-color);">Finality</td>
                    <td style="padding: 0.5rem; border: 1px solid var(--border-color); text-align: center;">Immediate, deterministic</td>
                    <td style="padding: 0.5rem; border: 1px solid var(--border-color); text-align: center;">Probabilistic or economic; often requires time</td>
                </tr>
                <tr>
                    <td style="padding: 0.5rem; border: 1px solid var(--border-color);">Communication</td>
                    <td style="padding: 0.5rem; border: 1px solid var(--border-color); text-align: center;">O(n) per block</td>
                    <td style="padding: 0.5rem; border: 1px solid var(--border-color); text-align: center;">Often O(n) among validators (when BFT-style)</td>
                </tr>
                <tr>
                    <td style="padding: 0.5rem; border: 1px solid var(--border-color);">Fault Tolerance</td>
                    <td style="padding: 0.5rem; border: 1px solid var(--border-color); text-align: center;">Up to f of 3f+1 Byzantine (‚â§1/3)</td>
                    <td style="padding: 0.5rem; border: 1px solid var(--border-color); text-align: center;">Honest majority of stake (&lt;50% adversarial)</td>
                </tr>
            </table>
            
            <p><strong>Comparison with <span data-glossary="proof of work">Proof of Work (PoW)</span>:</strong> PoW does not use BFT: it uses the longest-chain rule (<span data-glossary="nakamoto consensus">Nakamoto consensus</span>). There is no fixed validator set (any miner can participate), only <em>probabilistic</em> finality (confirmations over time), and security relies on honest majority of hashrate (attack requires &gt;50% hashrate). BFT gives deterministic finality and provable safety with ‚â§1/3 Byzantine nodes.</p>

            <h3>When to Use BFT</h3>
            <ul>
                <li>Need immediate finality</li>
                <li>Fixed validator set is acceptable</li>
                <li>High throughput is critical</li>
                <li>Deterministic safety guarantees needed</li>
            </ul>
        </div>

        <div class="section">
            <h2>6. Exploring BFT in Hyperscale-rs</h2>
            
            <h3>Key Files to Explore</h3>
            <p>View these in the repo (links open the file on GitHub):</p>
            <ol>
                <li><a href="https://github.com/flightofthefox/hyperscale-rs/blob/main/crates/bft/src/lib.rs" target="_blank" rel="noopener">crates/bft/src/lib.rs</a> ‚Äî module documentation</li>
                <li><a href="https://github.com/flightofthefox/hyperscale-rs/blob/main/crates/bft/src/state.rs" target="_blank" rel="noopener">crates/bft/src/state.rs</a> ‚Äî BFT state machine implementation</li>
                <li><a href="https://github.com/flightofthefox/hyperscale-rs/blob/main/crates/bft/src/vote_set.rs" target="_blank" rel="noopener">crates/bft/src/vote_set.rs</a> ‚Äî vote collection and QC formation</li>
                <li><a href="https://github.com/flightofthefox/hyperscale-rs/blob/main/guides/04-consensus-protocol.md" target="_blank" rel="noopener">guides/04-consensus-protocol.md</a> ‚Äî detailed protocol documentation</li>
            </ol>

            <h3>Practical Exercise</h3>
            <p>Open <a href="https://github.com/flightofthefox/hyperscale-rs/blob/main/crates/bft/src/lib.rs" target="_blank" rel="noopener">crates/bft/src/lib.rs</a> in the repo and find:</p>
            <ul>
                <li>The definition of a quorum (how many votes needed?)</li>
                <li>The commit rule (when does a block commit?)</li>
                <li>The fault tolerance (how many Byzantine nodes can be tolerated?)</li>
            </ul>
        </div>

        <div class="section">
            <h2>7. Knowledge Check Quiz</h2>
            <div id="quiz-02" class="quiz-container"></div>
        </div>

        <div class="section">
            <h2>8. Practical Assignment</h2>
            <div class="assignment">
                <h3>Assignment: Understanding BFT Consensus</h3>
                
                <h4>Tasks:</h4>
                <ol>
                    <li><strong>Read protocol docs and code in the repo</strong>:
                        <ul>
                            <li>View <a href="https://github.com/flightofthefox/hyperscale-rs/blob/main/guides/04-consensus-protocol.md" target="_blank" rel="noopener">guides/04-consensus-protocol.md</a> and <a href="https://github.com/flightofthefox/hyperscale-rs/blob/main/crates/bft/src/lib.rs" target="_blank" rel="noopener">crates/bft/src/lib.rs</a> (module docs at top)</li>
                            <li>Take notes on key concepts</li>
                        </ul>
                    </li>
                    <li><strong>Trace a block through consensus</strong>:
                        <ul>
                            <li>Open <a href="https://github.com/flightofthefox/hyperscale-rs/blob/main/crates/bft/src/state.rs" target="_blank" rel="noopener">crates/bft/src/state.rs</a> in the repo</li>
                            <li>Find the block proposal function</li>
                            <li>Find the vote handling function</li>
                            <li>Find the QC formation logic</li>
                            <li>Find the commit logic</li>
                            <li>Create a diagram showing the flow</li>
                        </ul>
                    </li>
                    <li><strong>Answer Questions</strong>:
                        <ul>
                            <li>In a system with 7 validators, how many can be Byzantine?</li>
                            <li>How many votes are needed for a quorum in a 7-validator system?</li>
                            <li>When does block H commit in HotStuff-2?</li>
                            <li>What is the difference between a vote and a QC?</li>
                        </ul>
                    </li>
                    <li><strong>Update Learning Journal</strong>:
                        <ul>
                            <li>Add a section on BFT consensus</li>
                            <li>Document what you learned</li>
                            <li>List questions you still have</li>
                        </ul>
                    </li>
                </ol>

                <h4>Success Criteria:</h4>
                <ul>
                    <li>‚úÖ You can explain BFT to someone else</li>
                    <li>‚úÖ You understand quorum certificates</li>
                    <li>‚úÖ You can trace through the code</li>
                    <li>‚úÖ You can answer the questions correctly</li>
                </ul>
            </div>
        </div>

        <div class="navigation">
            <a href="../index.html" class="btn btn-secondary">‚Üê Back to Index</a>
            <button id="complete-module-btn" class="btn btn-primary">Mark as Complete</button>
            <a href="module-03-distributed-systems.html" class="btn btn-primary">Next Module ‚Üí</a>
        </div>
    </div>

    <script src="../shared/course-data.js"></script>
    <script src="../shared/navigation.js"></script>
    <script src="../shared/glossary.js"></script>
    <script>
        initializeModulePage('basic-02');

        const quizQuestions = [
            {
                question: "In a BFT system with n=7 validators, how many can be Byzantine?",
                options: [
                    "1",
                    "2",
                    "3",
                    "4"
                ],
                correct: 1
            },
            {
                question: "What is the minimum number of votes needed for a quorum in a 7-validator BFT system?",
                options: [
                    "3",
                    "4",
                    "5",
                    "6"
                ],
                correct: 2
            },
            {
                question: "When does a block commit in HotStuff-2?",
                options: [
                    "When it gets a QC",
                    "When the next block gets a QC (two-chain rule)",
                    "When 2f+1 validators vote",
                    "After a timeout period"
                ],
                correct: 1
            },
            {
                question: "What is a Quorum Certificate (QC)?",
                options: [
                    "A certificate from a single validator",
                    "Cryptographic proof that 2f+1 validators voted",
                    "A block that contains transactions",
                    "A network message"
                ],
                correct: 1
            },
            {
                question: "How does the H+1 proposer get the QC for block H to include in block H+1?",
                options: [
                    "The QC is broadcast to all validators when formed",
                    "Votes are broadcast to the shard; the next proposer forms the QC from votes (or gets it from a received block header) and includes it in block H+1",
                    "Validators vote again to send the QC to the next proposer",
                    "The QC is read from the blockchain"
                ],
                correct: 1
            },
            {
                question: "What is the main advantage of BFT over PoS?",
                options: [
                    "Lower communication overhead",
                    "Immediate, deterministic finality",
                    "Dynamic validator set",
                    "No need for cryptography"
                ],
                correct: 1
            }
        ];

        initializeQuiz('quiz-02', quizQuestions, 70);
    </script>
</body>
</html>